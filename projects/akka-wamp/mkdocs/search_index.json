{
    "docs": [
        {
            "location": "/", 
            "text": "Akka Wamp\n\n\nAkka Wamp is a WAMP - \nWeb Application Messaging Protocol\n implementation written in \nScala\n with \nAkka\n\n\nEasy to download as \nSBT\n library dependency.\n\n\nlibraryDependencies ++= Seq(\n  \ncom.github.angiolep\n % \nakka-wamp_2.11\n % \n0.10.0\n\n)  \n\n\n\n\nClient API\n\n\nConnect to a router, open a session, subscribe a topic, receive events, register a procedure and call it in few lines of Scala!\n\n\nobject PubSubApp extends App {\n\n  import akka.wamp.client._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  val publication = \n    for {\n      session \n- client\n        .openSession(\n          url = \nws://localhost:8080/router\n,\n          subprotocol = \nwamp.2.json\n,\n          realm = \nakka.wamp.realm\n,\n          roles = Set(\nsubscriber\n))\n      subscription \n- session\n        .subscribe(\n          topic = \nmyapp.topic1\n)(\n          event =\n\n            event.data.map(println)\n        )\n      publication \n- session\n        .publish(\n          topic = \nmyapp.topic2\n,\n          ack = false,\n          kwdata = Map(\nname\n-\npaolo\n, \nage\n-\n40)\n        )\n    } yield ()\n}\n\n\n\n\nMajor features\n\n\n\n\nProper connection and \nSession Handling\n\n\nSimple and concise \nPublish Subscribe\n\n\nSimple and concise routed \nRemote Procedure Call\n\n\nLazy \nPayload Handling\n with Streaming support\n\n\n\n\nPlease, read the docs for \nfurther details\n\n\nRouter\n\n\nAkka Wamp provides you with a router that can be either embedded into your application or launched as standalone server process.\n\n\nLimitations\n\n\n\n\nScala 2.11 only (no older Scala)\n\n\nWebSocket transport only (no raw TCP and no SSL/TLS yet) \n\n\nProvide WAMP Basic Profile only (no Advanced Profile yet)\n\n\nProvide Publish/Subscribe only (no routed RPC yet)\n\n\nProvide JSON serialization only (no MsgPack yet)\n\n\n\n\nLicence\n\n\nThis software comes with \nApache License 2.0", 
            "title": "Home"
        }, 
        {
            "location": "/#akka-wamp", 
            "text": "Akka Wamp is a WAMP -  Web Application Messaging Protocol  implementation written in  Scala  with  Akka  Easy to download as  SBT  library dependency.  libraryDependencies ++= Seq(\n   com.github.angiolep  %  akka-wamp_2.11  %  0.10.0 \n)", 
            "title": "Akka Wamp"
        }, 
        {
            "location": "/#client-api", 
            "text": "Connect to a router, open a session, subscribe a topic, receive events, register a procedure and call it in few lines of Scala!  object PubSubApp extends App {\n\n  import akka.wamp.client._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  val publication = \n    for {\n      session  - client\n        .openSession(\n          url =  ws://localhost:8080/router ,\n          subprotocol =  wamp.2.json ,\n          realm =  akka.wamp.realm ,\n          roles = Set( subscriber ))\n      subscription  - session\n        .subscribe(\n          topic =  myapp.topic1 )(\n          event = \n            event.data.map(println)\n        )\n      publication  - session\n        .publish(\n          topic =  myapp.topic2 ,\n          ack = false,\n          kwdata = Map( name - paolo ,  age - 40)\n        )\n    } yield ()\n}", 
            "title": "Client API"
        }, 
        {
            "location": "/#major-features", 
            "text": "Proper connection and  Session Handling  Simple and concise  Publish Subscribe  Simple and concise routed  Remote Procedure Call  Lazy  Payload Handling  with Streaming support   Please, read the docs for  further details", 
            "title": "Major features"
        }, 
        {
            "location": "/#router", 
            "text": "Akka Wamp provides you with a router that can be either embedded into your application or launched as standalone server process.", 
            "title": "Router"
        }, 
        {
            "location": "/#limitations", 
            "text": "Scala 2.11 only (no older Scala)  WebSocket transport only (no raw TCP and no SSL/TLS yet)   Provide WAMP Basic Profile only (no Advanced Profile yet)  Provide Publish/Subscribe only (no routed RPC yet)  Provide JSON serialization only (no MsgPack yet)", 
            "title": "Limitations"
        }, 
        {
            "location": "/#licence", 
            "text": "This software comes with  Apache License 2.0", 
            "title": "Licence"
        }, 
        {
            "location": "/router/", 
            "text": "Akka Wamp provides you with a router that can be either embedded into your application or launched as standalone server process.\n\n\nEmbedded\n\n\nMake your SBT build depend on akka-wamp:\n\n\nscalaVersion := \n2.11.8\n\n\nlibraryDependencies ++= Seq(\n  \ncom.github.angiolep\n %% \nakka-wamp\n % \n0.10.0\n\n  // ...\n)\n\n\n\n\nCreate the Akka \nActorSystem\n and the Akka Wamp \nRouter\n actor as follows:\n\n\nimport akka.actor._\nimport akka.wamp.router._\n\nimplicit val system = ActorSystem(\nwamp\n)\nval router = system.actorOf(Router.props(), \nrouter\n)\n\n\n\n\nThen send a \nBind\n message to the \nIO(Wamp)\n manager\n\n\nIO(Wamp) ! Bind(router)\n\n\n\n\nDone ;-)\n\n\nStandalone \n\n\nDownload and launch the router as standalone application:\n\n\ncurl https://dl.bintray.com/angiolep/universal/akka-wamp-0.10.0.tgz\ntar xvfz akka-wamp-0.10.0.tar.gz\ncd akka-wamp-0.10.0\n./bin/akka-wamp -Dakka.loglevel=DEBUG\n\n\n\n\nConfiguration\n\n\nEither the embedded or the standalone router can be configured by applying the following configuration:\n\n\nakka {\n  wamp {\n    router {\n      # The TCP interface to bind to\n      #\n      iface = \n127.0.0.1\n\n\n      # The TCP port number (between 0 and 65536) to bind to\n      #\n      port = 8080\n\n      # The URL path incoming HTTP Upgrade request are\n      # expected to be addressed to\n      #\n      path = \nrouter\n\n\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # The boolean switch to NOT automatically create \n      # realms if they don't exist yet.\n      #\n      abort-unknown-realms = false\n\n      # The boolean switch to disconnect those peers that send \n      # offending messages (e.g. not deserializable or causing\n      # session failures)\n      #\n      # By default, offending messages are just dropped and \n      # the router resumes processing next incoming messages\n      #\n      disconnect-offending-peers = false\n    }\n  }\n}\n\n\n\n\nAbove settings can be overridden by\n\n\n\n\nproviding a TypeSafe Config \napplication.conf\n file right in the classpath,\n\n\nor passing Java system properties (e.g. \n-Dakka.wamp.router.port=7070\n) to the Java interpreter on the command line", 
            "title": "Router"
        }, 
        {
            "location": "/router/#embedded", 
            "text": "Make your SBT build depend on akka-wamp:  scalaVersion :=  2.11.8 \n\nlibraryDependencies ++= Seq(\n   com.github.angiolep  %%  akka-wamp  %  0.10.0 \n  // ...\n)  Create the Akka  ActorSystem  and the Akka Wamp  Router  actor as follows:  import akka.actor._\nimport akka.wamp.router._\n\nimplicit val system = ActorSystem( wamp )\nval router = system.actorOf(Router.props(),  router )  Then send a  Bind  message to the  IO(Wamp)  manager  IO(Wamp) ! Bind(router)  Done ;-)", 
            "title": "Embedded"
        }, 
        {
            "location": "/router/#standalone", 
            "text": "Download and launch the router as standalone application:  curl https://dl.bintray.com/angiolep/universal/akka-wamp-0.10.0.tgz\ntar xvfz akka-wamp-0.10.0.tar.gz\ncd akka-wamp-0.10.0\n./bin/akka-wamp -Dakka.loglevel=DEBUG", 
            "title": "Standalone"
        }, 
        {
            "location": "/router/#configuration", 
            "text": "Either the embedded or the standalone router can be configured by applying the following configuration:  akka {\n  wamp {\n    router {\n      # The TCP interface to bind to\n      #\n      iface =  127.0.0.1 \n\n      # The TCP port number (between 0 and 65536) to bind to\n      #\n      port = 8080\n\n      # The URL path incoming HTTP Upgrade request are\n      # expected to be addressed to\n      #\n      path =  router \n\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # The boolean switch to NOT automatically create \n      # realms if they don't exist yet.\n      #\n      abort-unknown-realms = false\n\n      # The boolean switch to disconnect those peers that send \n      # offending messages (e.g. not deserializable or causing\n      # session failures)\n      #\n      # By default, offending messages are just dropped and \n      # the router resumes processing next incoming messages\n      #\n      disconnect-offending-peers = false\n    }\n  }\n}  Above settings can be overridden by   providing a TypeSafe Config  application.conf  file right in the classpath,  or passing Java system properties (e.g.  -Dakka.wamp.router.port=7070 ) to the Java interpreter on the command line", 
            "title": "Configuration"
        }, 
        {
            "location": "/client/actor/", 
            "text": "Actor based API\n\n\nAkka Wamp provides you with an \nActor\n based API to let you write your client with a low-level API and have full control of it!\n\n\nFor the \nimpatients\n\n\nLet's connect a transport, open a session, subscribe a topic and receive events:\n\n\nimport akka.actor._\nimport akka.io._\nimport akka.wamp._\n\nimplicit val system = ActorSystem(\nmyapp\n)\n\nval client = system.actorOf(Props[MyClient])\nIO(Wamp) ! Wamp.Connect(client, \nws://localhost:8080/router\n)\n\nclass MyClient extends Actor {\n  var router: ActorRef = _\n  def receive = {\n    case signal @ Wamp.Connected(r) =\n\n      router = r\n      IO(Wamp) ! Wamp.Disconnect\n  }\n}", 
            "title": "Actor based API"
        }, 
        {
            "location": "/client/actor/#actor-based-api", 
            "text": "Akka Wamp provides you with an  Actor  based API to let you write your client with a low-level API and have full control of it!", 
            "title": "Actor based API"
        }, 
        {
            "location": "/client/actor/#for-the-impatients", 
            "text": "Let's connect a transport, open a session, subscribe a topic and receive events:  import akka.actor._\nimport akka.io._\nimport akka.wamp._\n\nimplicit val system = ActorSystem( myapp )\n\nval client = system.actorOf(Props[MyClient])\nIO(Wamp) ! Wamp.Connect(client,  ws://localhost:8080/router )\n\nclass MyClient extends Actor {\n  var router: ActorRef = _\n  def receive = {\n    case signal @ Wamp.Connected(r) = \n      router = r\n      IO(Wamp) ! Wamp.Disconnect\n  }\n}", 
            "title": "For the impatients"
        }, 
        {
            "location": "/client/future/overview/", 
            "text": "Future based API\n\n\nAkka Wamp provides you with an \nAkka Future\n based API, built on top of \nAkka Wamp Actor based API\n, to let you write your client with a high-level API and few lines of elegant and succinct Scala!\n\n\nIt provides:\n\n\n\n\nSession Handling\n\n\nPublish Subscribe\n\n\nRemote Procedure Call\n\n\nPayload Handling", 
            "title": "Overview"
        }, 
        {
            "location": "/client/future/overview/#future-based-api", 
            "text": "Akka Wamp provides you with an  Akka Future  based API, built on top of  Akka Wamp Actor based API , to let you write your client with a high-level API and few lines of elegant and succinct Scala!  It provides:   Session Handling  Publish Subscribe  Remote Procedure Call  Payload Handling", 
            "title": "Future based API"
        }, 
        {
            "location": "/client/future/session/", 
            "text": "Session Handling\n\n\nimport akka.wamp.client._\nval client = Client(\nmyapp\n)\n\nimplicit val ec = client.executionContext\n\nval session = client\n  .connect(\n    url = \nws://localhost:8080/router\n,\n    subprotocol = \nwamp.2.json\n)\n  .openSession(\n    realm = \nakka.wamp.realm\n,\n    roles = Set(\nsubscriber\n)\n  )\n}\n\n\n\n\nCreate the client and establish connections to open sessions.\n\n\nCreate clients\n\n\nimport akka.wamp.client._\nval client = Client(\nmyapp\n)\n\n\n\n\nCreate the client by invoking the \nClient\n companion object factory method with the following arguments\n\n\n\n\n\n\nname\n\n   The unique name of the client (default is \n\"default\"\n)\n\n\n\n\n\n\nconfig\n\n   The configuration object (default is \nConfigFactory.load()\n as per standard behaviour of \nTypeSafe Config\n)\n\n\n\n\n\n\nThe factory method creates an \nAkka ActorSystem\n named after the client and configured with the given configuration object. \n\n\nConfiguration\n\n\nTBD\n\n\nMultiplicity\n\n\nIn Akka Wamp, one client can establish many connections but each connection can open only one session.\n\n\n    ,--------.  1      0..n  ,------------.  1      0..1  ,---------. \n    | Client |  -----------  | Connection |  -----------  | Session | \n    `--------'               `------------'               `---------'\n\n\n\n\nBear in mind that, though you could create as many client as you wish, its actor system is a heavyweight structure that allocates 1..n threads. So you're advised to create \none client per logical application\n.\n\n\nExecution context\n\n\nAll of the operation provided by client, connection and sessions objects always return futures. In order to execute callbacks and operations, futures need something called an \nExecutionContext\n. You can import the existing \nclient.executionContext\n as implicit in scope:\n\n\nimplicit val ec = client.executionContext\n\n\n\n\nor create your own.\n\n\nEstablish connections\n\n\nimport scala.concurrent.Future\n\nval conn1: Future[Connection] = client\n  .connect(\n    url = \nws://localhost:8080/router\n,\n    subprotocol = \nwamp.2.json\n)\n\nval conn2 = client\n  .connect(\n    url = \nwss://secure.host.net:443/wamp\n,\n    subprotocol = \nwamp.2.msgpack\n)    \n\n\n\n\nEstablish a connection to a router invoking the client \nconnect()\n method which accepts \nurl\n and \nsubprotocol\n arguments as documented for the \nConnect\n message constructor. \n\n\nYou can establish as many connections as you wish (to the same or to different routers) as the connect method returns a distinct (future of) connection.\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) connection fails. To recover from failures (such as \nConnectionException\n thrown when router cannot accept connection) you can compose \nrecoverWith\n to attempt another connection (maybe to a fallback router):\n\n\nval conn1: Future[Connection] = client\n  .connect(\n    url = \nws://localhost:8080/router\n)\n  .recoverWith { \n    case ex: ConnectionException =\n client\n      .connect(\n        url = \nws://fallback.host.net:9999/path\n)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that terminates the application:\n\n\nconn.onFailure {\n  case ex: Throwable =\n\n    client.terminate().map(_ =\n System.exit(-1))\n}\n\n\n\n\nOpen sessions\n\n\nval session1: Future[Session] = conn1.flatMap(\n  _.openSession(\n    realm = \nakka.wamp.realm\n,\n    roles = Set(\nsubscriber\n)))\n\nval session2 = conn2.flatMap(\n  _.openSession(\n    roles = Set(\npublisher\n, \ncallee\n)))    \n\n\n\n\nA (future of) connection can be mapped to a (future of) session by just invoking the connection \nopenSession()\n method which accepts \nrealm\n and \nroles\n arguments as documented for the \nHello\n message constructor. \n\n\nYou can open only one session per connection. Therefore, if you wish to open a second session then you must establish a second connection (using the same client or a different one).\n\n\nShortcut\n\n\nYou can shortcut connection establishment and session opening in one single concise statement by invoking \nopenSession()\n on the client rather than on the connection:\n\n\nval session: Future[Session] = client\n  .openSession(\n    url = \nws://some.host.net:8080/ws\n,\n    subprotocol = \nwamp.2.json\n,\n    realm = \nakka.wamp.realm\n,\n    roles = Set(\nsubscriber\n, \ncaller\n))\n\n\n\n\nThe client \nopenSession()\n method accepts all of the \nurl\n, \nsubprotocol\n, \nrealm\n and \ndetails\n arguments mentioned above. It establishes a new connection and opens a new session each time you call it.\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) session fails. To recover from failures (such as \nAbortException\n thrown when router doesn't attach to a realm) you can compose \nrecoverWith\n to attempt another session opening (maybe to a fallback realm):\n\n\nval session: Future[Session] = client\n  .openSession(\n    realm = \nakka.wamp.realm\n)\n  .recoverWith { \n    case ex: AbortException =\n client\n      .openSession(\n        realm = \nfallback.realm\n)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\nsession.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nClose sessions\n\n\nTBD\n\n\nDisconnect transports\n\n\nTBD\n\n\nTerminate clients\n\n\nTBD", 
            "title": "Session Handling"
        }, 
        {
            "location": "/client/future/session/#session-handling", 
            "text": "import akka.wamp.client._\nval client = Client( myapp )\n\nimplicit val ec = client.executionContext\n\nval session = client\n  .connect(\n    url =  ws://localhost:8080/router ,\n    subprotocol =  wamp.2.json )\n  .openSession(\n    realm =  akka.wamp.realm ,\n    roles = Set( subscriber )\n  )\n}  Create the client and establish connections to open sessions.", 
            "title": "Session Handling"
        }, 
        {
            "location": "/client/future/session/#create-clients", 
            "text": "import akka.wamp.client._\nval client = Client( myapp )  Create the client by invoking the  Client  companion object factory method with the following arguments    name \n   The unique name of the client (default is  \"default\" )    config \n   The configuration object (default is  ConfigFactory.load()  as per standard behaviour of  TypeSafe Config )    The factory method creates an  Akka ActorSystem  named after the client and configured with the given configuration object.", 
            "title": "Create clients"
        }, 
        {
            "location": "/client/future/session/#configuration", 
            "text": "TBD", 
            "title": "Configuration"
        }, 
        {
            "location": "/client/future/session/#multiplicity", 
            "text": "In Akka Wamp, one client can establish many connections but each connection can open only one session.      ,--------.  1      0..n  ,------------.  1      0..1  ,---------. \n    | Client |  -----------  | Connection |  -----------  | Session | \n    `--------'               `------------'               `---------'  Bear in mind that, though you could create as many client as you wish, its actor system is a heavyweight structure that allocates 1..n threads. So you're advised to create  one client per logical application .", 
            "title": "Multiplicity"
        }, 
        {
            "location": "/client/future/session/#execution-context", 
            "text": "All of the operation provided by client, connection and sessions objects always return futures. In order to execute callbacks and operations, futures need something called an  ExecutionContext . You can import the existing  client.executionContext  as implicit in scope:  implicit val ec = client.executionContext  or create your own.", 
            "title": "Execution context"
        }, 
        {
            "location": "/client/future/session/#establish-connections", 
            "text": "import scala.concurrent.Future\n\nval conn1: Future[Connection] = client\n  .connect(\n    url =  ws://localhost:8080/router ,\n    subprotocol =  wamp.2.json )\n\nval conn2 = client\n  .connect(\n    url =  wss://secure.host.net:443/wamp ,\n    subprotocol =  wamp.2.msgpack )      Establish a connection to a router invoking the client  connect()  method which accepts  url  and  subprotocol  arguments as documented for the  Connect  message constructor.   You can establish as many connections as you wish (to the same or to different routers) as the connect method returns a distinct (future of) connection.", 
            "title": "Establish connections"
        }, 
        {
            "location": "/client/future/session/#recover", 
            "text": "You can either recover or  \"give up\"  when the (future of) connection fails. To recover from failures (such as  ConnectionException  thrown when router cannot accept connection) you can compose  recoverWith  to attempt another connection (maybe to a fallback router):  val conn1: Future[Connection] = client\n  .connect(\n    url =  ws://localhost:8080/router )\n  .recoverWith { \n    case ex: ConnectionException =  client\n      .connect(\n        url =  ws://fallback.host.net:9999/path )\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that terminates the application:  conn.onFailure {\n  case ex: Throwable = \n    client.terminate().map(_ =  System.exit(-1))\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/session/#open-sessions", 
            "text": "val session1: Future[Session] = conn1.flatMap(\n  _.openSession(\n    realm =  akka.wamp.realm ,\n    roles = Set( subscriber )))\n\nval session2 = conn2.flatMap(\n  _.openSession(\n    roles = Set( publisher ,  callee )))      A (future of) connection can be mapped to a (future of) session by just invoking the connection  openSession()  method which accepts  realm  and  roles  arguments as documented for the  Hello  message constructor.   You can open only one session per connection. Therefore, if you wish to open a second session then you must establish a second connection (using the same client or a different one).", 
            "title": "Open sessions"
        }, 
        {
            "location": "/client/future/session/#shortcut", 
            "text": "You can shortcut connection establishment and session opening in one single concise statement by invoking  openSession()  on the client rather than on the connection:  val session: Future[Session] = client\n  .openSession(\n    url =  ws://some.host.net:8080/ws ,\n    subprotocol =  wamp.2.json ,\n    realm =  akka.wamp.realm ,\n    roles = Set( subscriber ,  caller ))  The client  openSession()  method accepts all of the  url ,  subprotocol ,  realm  and  details  arguments mentioned above. It establishes a new connection and opens a new session each time you call it.", 
            "title": "Shortcut"
        }, 
        {
            "location": "/client/future/session/#recover_1", 
            "text": "You can either recover or  \"give up\"  when the (future of) session fails. To recover from failures (such as  AbortException  thrown when router doesn't attach to a realm) you can compose  recoverWith  to attempt another session opening (maybe to a fallback realm):  val session: Future[Session] = client\n  .openSession(\n    realm =  akka.wamp.realm )\n  .recoverWith { \n    case ex: AbortException =  client\n      .openSession(\n        realm =  fallback.realm )\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  session.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/session/#close-sessions", 
            "text": "TBD", 
            "title": "Close sessions"
        }, 
        {
            "location": "/client/future/session/#disconnect-transports", 
            "text": "TBD", 
            "title": "Disconnect transports"
        }, 
        {
            "location": "/client/future/session/#terminate-clients", 
            "text": "TBD", 
            "title": "Terminate clients"
        }, 
        {
            "location": "/client/future/pubsub/", 
            "text": "Publish and Subscribe\n\n\nobject PubSubApp extends App {\n\n  import akka.wamp.client._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  val publication = \n    for {\n      session \n- client\n        .openSession(\n          url = \nws://localhost:8080/router\n,\n          subprotocol = \nwamp.2.json\n,\n          realm = \nakka.wamp.realm\n,\n          roles = Set(\nsubscriber\n))\n      subscription \n- session\n        .subscribe(\n          topic = \nmyapp.topic1\n)(\n          event =\n\n            event.data.map(println)\n        )\n      publication \n- session\n        .publish(\n          topic = \nmyapp.topic2\n,\n          ack = false,\n          kwdata = Map(\nname\n-\npaolo\n, \nage\n-\n40)\n        )\n    } yield ()\n}\n\n\n\n\nThe WAMP protocol defines a Publish and Subscribe (PubSub) communication pattern where a client, the subscriber, informs the broker router that it wants to receive events on a topic (i.e., it subscribes to a topic). Another client, a publisher, can then publish events to this topic, and the broker router distributes events to all subscriber.\n\n\n  ,---------.          ,------.             ,----------.\n  |Publisher|          |Broker|             |Subscriber|\n  `----+----'          `--+---'             `----+-----'\n       |                  |                      |\n       |                  |            SUBSCRIBE |\n       |                  \n---------------------|\n       |                  |                      |\n       |                  | SUBSCRIBED           |\n       |                  |---------------------\n\n       |                  |                      |\n       |                  |                      |\n       | PUBLISH          |                      |\n       |-----------------\n                      |\n       |                  |                      |\n       |        PUBLISHED |                      |\n       \n-----------------|                      |\n       |                  |                      |\n       |                  |  EVENT               |\n       |                  |---------------------\n\n       |                  |                      |\n  ,----+----.          ,--+---.             ,----+-----.\n  |Publisher|          |Broker|             |Subscriber|\n  `---------'          `------'             `----------'\n\n\n\n\nSubscribe topics\n\n\nOnce you got a subscriber session as documented in the \nSession Handling\n section, you can finally subscribe to a topic with its event handler:\n\n\nimport akka.wamp._\nimport akka.wamp.message._\n\n// implicit val executionContext = ...\n// val session = ... \n\nval subscription: Future[Subscription] = session.flatMap(\n  _.subscribe(\n    topic = \nmyapp.topic\n) { \n    event =\n\n      log.info(s\n${event.publicationId}\n)\n      event.data.map(println)\n    })\n\n\n\n\nA (future of) session can be mapped to a (future of) subscription by just invoking the \nsubscribe\n method. It is a curried method with two parameter lists.\n\n\n// as defined by Akka Wamp\n\ndef subscribe(topic: Uri)(handler: EventHandler)\n\n\n\n\nThe first parameter list accepts \ntopic\n as documented for the \nSubscribe\n message constructor. The second parameter list accepts a callback function of type \nEventHandler\n which gets invoked to process each event from the topic. \n\n\nEvent handlers\n\n\n// as defined by Akka Wamp\ntype EventHandler = (Event) =\n Unit\n\n\n\n\nThe event handler is a function with side-effects that transforms an event to \nunit\n (like \nvoid\n for Java). The event comes with an input payload whose content can be lazily parsed as input data. \n\n\n// your event handler\nval handler: EventHandler = { event =\n\n  event.data.map { data =\n\n    println(data)\n  }\n}\n\n\n\n\nReceiving application data is documented in the \nPayload Handling\n section.  \n\n\nMultiple handlers\n\n\nval handler1: EventHandler = { event =\n\n  event.data.map { data =\n\n    println(s\n(1) \n-- $data\n)\n  }\n}\nval handler2: EventHandler = { event =\n\n  event.data.map { data =\n\n    println(s\n(2) \n-- $data\n)\n  }\n}\n\n// let's subscribe them to the same topic! \n\nval subscription1 = session.flatMap(\n  _.subscribe(\n    topic = \nmyapp.topic\n)(\n    handler1))\n\nval subscription2 = session.flatMap(\n  _.subscribe(\n    topic = \nmyapp.topic\n)(\n    handler2))\n\n\n\n\nYou can subscribe many times to the same topic passing the same or different event handlers. As per WAMP protocol specification, the correspondent subscriptions held by the router will share the same subscription identifier. Therefore, your Akka Wamp client subscriber will: \n\n\n\n\nadd your event handlers in the same set linked to the same subscription identifier,\n\n\ninvoke all of them anytime an event with that subscription identifier is received.\n\n\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) subscription fails. To recover from failures (such as \nSessionException\n thrown when session turns out to be closed) you can compose \nrecoverWith\n to attempt another session opening (maybe to a fallback realm and/or to a fallback topic):\n\n\nval subscription = session.flatMap(\n  _.subscribe(\nmyapp.topic\n)(handler)\n  .recoverWith { \n    case ex: SessionException =\n session.flatMap(\n      _.subscribe(\nmyapp.topic.heartbeat\n)(handler)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\nsession.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nUnsubscribe topics\n\n\nimport akka.wamp.messages._\n\nval unsubscribed: Future[Unsubscribed] = session.flatMap(\n    _.unsubscribe(\nmyapp.topic\n)\n  )\n\n\n\n\nMultiple handlers\n\n\nTBD\n\n\nPublish events\n\n\nimport akka.Done\nimport akka.wamp.serialization._\n\nval publication: Future[Either[Done, Publication]] = session.flatMap(\n  _.publish(\n    topic = \nmyapp.topic\n,\n    payload = Payload(\npaolo\n, 40, true),\n    ack = true\n  ))\n\n\n\n\nA (future of) session can be mapped to a (future of) either done or publication by just invoking the \npublish\n method which accepts \ntopic\n, \nack\n and a \npayload\n arguments as documented for the \nPublish\n message constructor. Sending arguments is documented in the \nPayload Handling\n section.  \n\n\nAcknowledge\n\n\nNote that if you leave \nack\n switched off (as by default) then Akka Wamp will not expect to receive the \nPublished\n message back from the router and the (future of either of) publication or done immediately completes with (left of) \nDone\n. Otherwise, if you switch \nack\n on then the (future of either of) publication or done later completes with (right of) \nPublication\n (if no exception were thrown).\n\n\nYou could pass a callback \nonSuccess\n to better understand what really happens:\n\n\n// ack = true\npublication.onSuccess {\n  case Success(Left(Done)) =\n\n    println(s\nPublication done\n) \n}\n\n// ack = false\npublication.onSuccess {\n  case Success(Right(p)) =\n\n    println(s\nPublished with ${p.publicationId}\n)\n}\n\n\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) publication fails. To recover from failures (such as \nSessionException\n when session turns out to be closed as you try to publish) you can compose \nrecoverWith\n  to attempt another session opening (maybe to a fallback realm and to a fallback topic):\n\n\nval publication = session1.flatMap(_.publish(\nmyapp.topic.ticking\n)\n  .recoverWith { \n    case ex: SessionException =\n\n      for {\n        session2 \n- client.openSession()\n        publication2 \n- session2.publish(\nmyapp.topic.heartbeat\n)\n      }\n      yield publication2\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\npublication.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/client/future/pubsub/#publish-and-subscribe", 
            "text": "object PubSubApp extends App {\n\n  import akka.wamp.client._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  val publication = \n    for {\n      session  - client\n        .openSession(\n          url =  ws://localhost:8080/router ,\n          subprotocol =  wamp.2.json ,\n          realm =  akka.wamp.realm ,\n          roles = Set( subscriber ))\n      subscription  - session\n        .subscribe(\n          topic =  myapp.topic1 )(\n          event = \n            event.data.map(println)\n        )\n      publication  - session\n        .publish(\n          topic =  myapp.topic2 ,\n          ack = false,\n          kwdata = Map( name - paolo ,  age - 40)\n        )\n    } yield ()\n}  The WAMP protocol defines a Publish and Subscribe (PubSub) communication pattern where a client, the subscriber, informs the broker router that it wants to receive events on a topic (i.e., it subscribes to a topic). Another client, a publisher, can then publish events to this topic, and the broker router distributes events to all subscriber.    ,---------.          ,------.             ,----------.\n  |Publisher|          |Broker|             |Subscriber|\n  `----+----'          `--+---'             `----+-----'\n       |                  |                      |\n       |                  |            SUBSCRIBE |\n       |                   ---------------------|\n       |                  |                      |\n       |                  | SUBSCRIBED           |\n       |                  |--------------------- \n       |                  |                      |\n       |                  |                      |\n       | PUBLISH          |                      |\n       |-----------------                       |\n       |                  |                      |\n       |        PUBLISHED |                      |\n        -----------------|                      |\n       |                  |                      |\n       |                  |  EVENT               |\n       |                  |--------------------- \n       |                  |                      |\n  ,----+----.          ,--+---.             ,----+-----.\n  |Publisher|          |Broker|             |Subscriber|\n  `---------'          `------'             `----------'", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/client/future/pubsub/#subscribe-topics", 
            "text": "Once you got a subscriber session as documented in the  Session Handling  section, you can finally subscribe to a topic with its event handler:  import akka.wamp._\nimport akka.wamp.message._\n\n// implicit val executionContext = ...\n// val session = ... \n\nval subscription: Future[Subscription] = session.flatMap(\n  _.subscribe(\n    topic =  myapp.topic ) { \n    event = \n      log.info(s ${event.publicationId} )\n      event.data.map(println)\n    })  A (future of) session can be mapped to a (future of) subscription by just invoking the  subscribe  method. It is a curried method with two parameter lists.  // as defined by Akka Wamp\n\ndef subscribe(topic: Uri)(handler: EventHandler)  The first parameter list accepts  topic  as documented for the  Subscribe  message constructor. The second parameter list accepts a callback function of type  EventHandler  which gets invoked to process each event from the topic.", 
            "title": "Subscribe topics"
        }, 
        {
            "location": "/client/future/pubsub/#event-handlers", 
            "text": "// as defined by Akka Wamp\ntype EventHandler = (Event) =  Unit  The event handler is a function with side-effects that transforms an event to  unit  (like  void  for Java). The event comes with an input payload whose content can be lazily parsed as input data.   // your event handler\nval handler: EventHandler = { event = \n  event.data.map { data = \n    println(data)\n  }\n}  Receiving application data is documented in the  Payload Handling  section.", 
            "title": "Event handlers"
        }, 
        {
            "location": "/client/future/pubsub/#multiple-handlers", 
            "text": "val handler1: EventHandler = { event = \n  event.data.map { data = \n    println(s (1)  -- $data )\n  }\n}\nval handler2: EventHandler = { event = \n  event.data.map { data = \n    println(s (2)  -- $data )\n  }\n}\n\n// let's subscribe them to the same topic! \n\nval subscription1 = session.flatMap(\n  _.subscribe(\n    topic =  myapp.topic )(\n    handler1))\n\nval subscription2 = session.flatMap(\n  _.subscribe(\n    topic =  myapp.topic )(\n    handler2))  You can subscribe many times to the same topic passing the same or different event handlers. As per WAMP protocol specification, the correspondent subscriptions held by the router will share the same subscription identifier. Therefore, your Akka Wamp client subscriber will:    add your event handlers in the same set linked to the same subscription identifier,  invoke all of them anytime an event with that subscription identifier is received.", 
            "title": "Multiple handlers"
        }, 
        {
            "location": "/client/future/pubsub/#recover", 
            "text": "You can either recover or  \"give up\"  when the (future of) subscription fails. To recover from failures (such as  SessionException  thrown when session turns out to be closed) you can compose  recoverWith  to attempt another session opening (maybe to a fallback realm and/or to a fallback topic):  val subscription = session.flatMap(\n  _.subscribe( myapp.topic )(handler)\n  .recoverWith { \n    case ex: SessionException =  session.flatMap(\n      _.subscribe( myapp.topic.heartbeat )(handler)\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  session.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/pubsub/#unsubscribe-topics", 
            "text": "import akka.wamp.messages._\n\nval unsubscribed: Future[Unsubscribed] = session.flatMap(\n    _.unsubscribe( myapp.topic )\n  )", 
            "title": "Unsubscribe topics"
        }, 
        {
            "location": "/client/future/pubsub/#multiple-handlers_1", 
            "text": "TBD", 
            "title": "Multiple handlers"
        }, 
        {
            "location": "/client/future/pubsub/#publish-events", 
            "text": "import akka.Done\nimport akka.wamp.serialization._\n\nval publication: Future[Either[Done, Publication]] = session.flatMap(\n  _.publish(\n    topic =  myapp.topic ,\n    payload = Payload( paolo , 40, true),\n    ack = true\n  ))  A (future of) session can be mapped to a (future of) either done or publication by just invoking the  publish  method which accepts  topic ,  ack  and a  payload  arguments as documented for the  Publish  message constructor. Sending arguments is documented in the  Payload Handling  section.", 
            "title": "Publish events"
        }, 
        {
            "location": "/client/future/pubsub/#acknowledge", 
            "text": "Note that if you leave  ack  switched off (as by default) then Akka Wamp will not expect to receive the  Published  message back from the router and the (future of either of) publication or done immediately completes with (left of)  Done . Otherwise, if you switch  ack  on then the (future of either of) publication or done later completes with (right of)  Publication  (if no exception were thrown).  You could pass a callback  onSuccess  to better understand what really happens:  // ack = true\npublication.onSuccess {\n  case Success(Left(Done)) = \n    println(s Publication done ) \n}\n\n// ack = false\npublication.onSuccess {\n  case Success(Right(p)) = \n    println(s Published with ${p.publicationId} )\n}", 
            "title": "Acknowledge"
        }, 
        {
            "location": "/client/future/pubsub/#recover_1", 
            "text": "You can either recover or  \"give up\"  when the (future of) publication fails. To recover from failures (such as  SessionException  when session turns out to be closed as you try to publish) you can compose  recoverWith   to attempt another session opening (maybe to a fallback realm and to a fallback topic):  val publication = session1.flatMap(_.publish( myapp.topic.ticking )\n  .recoverWith { \n    case ex: SessionException = \n      for {\n        session2  - client.openSession()\n        publication2  - session2.publish( myapp.topic.heartbeat )\n      }\n      yield publication2\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  publication.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/rpc/", 
            "text": "Remote Procedure Calls\n\n\nobject RpcApp extends App {\n\n  import akka.wamp.client._\n  import akka.wamp.serialization._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  val data = \n    for {\n      session \n- client\n        .openSession(\n          url = \nws://localhost:8080/router\n,\n          subprotocol = \nwamp.2.json\n,\n          realm = \nakka.wamp.realm\n,\n          roles = Set(\ncallee\n))\n      registration \n- session\n        .register(\n          procedure = \nmyapp.procedure\n)(\n          _.args.map { args =\n\n            Payload(args)\n          })\n      result \n- session\n        .call(\n          procedure = \nmyapp.procedure\n,\n          args = List(\npaolo\n, 40, true))\n      data \n- result.data\n    } \n    yield (data)\n\n  data.map(println)\n}\n\n\n\n\nThe WAMP protocol defines a routed Remote Procedure Call (RPC) mechanism which relies on the same sort of decoupling that is used by the \nPublish Subscribe\n communication pattern. \n\n\nA client, the callee, announces to the dealer router that it provides a certain procedure, identified by a procedure name.  Other clients, callers, can then call the procedure, with the dealer router invoking the procedure on the callee, receiving the procedure's result, and then forwarding this result back to the callers. Routed RPC differ from traditional client-server RPC in that the dealer router serves as an intermediary between the callers and the callee.\n\n\n   ,------.          ,------.               ,------.\n   |Caller|          |Dealer|               |Callee|\n   `--+---'          `--+---'               `--+---'   \n      |                 |             REGISTER |\n      |                 \n---------------------|\n      |                 |                      |\n      |                 | REGISTERED           |\n      |                 |---------------------\n\n      |                 |                      |\n      | CALL            |                      |\n      |----------------\n                      |\n      |                 |                      |\n      |                 | INVOCATION           | \n      |                 |---------------------\n\n      |                 |                      |\n      |                 |                YIELD |\n      |                 \n---------------------|\n      |                 |                      |\n      |          RESULT |                      |\n      \n----------------|                      |\n   ,--+---.          ,--+---.               ,--+---.\n   |Caller|          |Dealer|               |Callee|\n   `------'          `------'               `------'\n\n\n\n\nAkka Wamp provides you with an \nFuture\n based API to easily write both kind of clients: callee (those registering procedures) and callers (those calling them).\n\n\nRegister procedures\n\n\nOnce you got a callee session as documented in the \nSession Handling\n section, you can finally register a procedure and its invocation handler:\n\n\n// val session = ... \n\nval registration: Future[Registration] = session.flatMap(\n  _.register(\n    procedure = \nmyapp.procedure.echo\n) {\n    invocation =\n\n      invocation.args.map( args =\n\n        Payload(args)\n      )})\n\n\n\n\nA (future of) session can be mapped to a (future of) registration by just invoking the \nregister\n method. It is a curried method with two parameter lists.\n\n\n// as defined by Akka Wamp\ndef register(procedure: Uri)(handler: InvocationHandler)\n\n\n\n\nThe first parameter list accepts \nprocedure\n as documented for the \nRegister\n message constructor. The second parameter list accepts a callback function of type \nInvocationHandler\n.\n\n\nInvocation handlers\n\n\n// as defined by Akka Wamp\ntype InvocationHandler = (Invocation) =\n Future[Payload]\n\n\n\n\nThe invocation handler is a function that transforms an invocation to a (future of) output payload. The invocation comes with an input payload whose content can be lazily parsed as input arguments.\n\n\n// handler for \nmyapp.procedure.sum\n\nval handler: InvocationHandler = { invocation =\n\n  invocation.kwargs.map { kwargs =\n\n    val arg0 = kwargs(\n0\n).asInstanceOf[Int]\n    val arg1 = kwargs(\n1\n).asInstanceOf[Int]\n    Payload(List(arg0 + arg1))\n  }}\n\n\n\n\nArguments can be received from the incoming payload and replied back as documented in the \nPayload Handling\n section.\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) registration fails. To recover from failures (such as \nSessionException\n thrown when the procedure has been already registered by some other callee or when the session turns out to be closed) you can compose \nrecoverWith\n to attempt registering the procedure with a different name or to attempt another session (maybe to a fallback realm):\n\n\nval registration = session.flatMap(\n  _.register(\nmyapp.procedure.sum\n)(handler)\n  .recoverWith { \n    case ex: SessionException =\n session.flatMap(\n      _.register(\nmyapp.procedure.sum.renamed\n)(handler)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\nsession.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nUnregister procedures\n\n\nimport akka.wamp.messages._\n\nval unregisterd: Future[Unregisterd] = session.flatMap(\n    _.unregister(\nmyapp.procedure.sum\n)\n  )\n\n\n\n\nRecover\n\n\nTBD\n\n\nCall procedures\n\n\nOnce you got a caller session as documented in the \nSession Handling\n section, you can finally call a procedure:\n\n\n// val session = ... \n\nval result: Future[Result] = session.flatMap(\n  _.call(\n    procedure = \nmyapp.procedure.sum\n,\n    args = List(2, 4, 8, 12))\n)\n\nval data: Future[List[Any]] = result.flatMap(\n  _.data\n)\n\n\n\n\nArguments can be received from the resulting payload as documented in the \nPayload Handling\n section.\n\n\nRecover\n\n\nTBD", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/client/future/rpc/#remote-procedure-calls", 
            "text": "object RpcApp extends App {\n\n  import akka.wamp.client._\n  import akka.wamp.serialization._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  val data = \n    for {\n      session  - client\n        .openSession(\n          url =  ws://localhost:8080/router ,\n          subprotocol =  wamp.2.json ,\n          realm =  akka.wamp.realm ,\n          roles = Set( callee ))\n      registration  - session\n        .register(\n          procedure =  myapp.procedure )(\n          _.args.map { args = \n            Payload(args)\n          })\n      result  - session\n        .call(\n          procedure =  myapp.procedure ,\n          args = List( paolo , 40, true))\n      data  - result.data\n    } \n    yield (data)\n\n  data.map(println)\n}  The WAMP protocol defines a routed Remote Procedure Call (RPC) mechanism which relies on the same sort of decoupling that is used by the  Publish Subscribe  communication pattern.   A client, the callee, announces to the dealer router that it provides a certain procedure, identified by a procedure name.  Other clients, callers, can then call the procedure, with the dealer router invoking the procedure on the callee, receiving the procedure's result, and then forwarding this result back to the callers. Routed RPC differ from traditional client-server RPC in that the dealer router serves as an intermediary between the callers and the callee.     ,------.          ,------.               ,------.\n   |Caller|          |Dealer|               |Callee|\n   `--+---'          `--+---'               `--+---'   \n      |                 |             REGISTER |\n      |                  ---------------------|\n      |                 |                      |\n      |                 | REGISTERED           |\n      |                 |--------------------- \n      |                 |                      |\n      | CALL            |                      |\n      |----------------                       |\n      |                 |                      |\n      |                 | INVOCATION           | \n      |                 |--------------------- \n      |                 |                      |\n      |                 |                YIELD |\n      |                  ---------------------|\n      |                 |                      |\n      |          RESULT |                      |\n       ----------------|                      |\n   ,--+---.          ,--+---.               ,--+---.\n   |Caller|          |Dealer|               |Callee|\n   `------'          `------'               `------'  Akka Wamp provides you with an  Future  based API to easily write both kind of clients: callee (those registering procedures) and callers (those calling them).", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/client/future/rpc/#register-procedures", 
            "text": "Once you got a callee session as documented in the  Session Handling  section, you can finally register a procedure and its invocation handler:  // val session = ... \n\nval registration: Future[Registration] = session.flatMap(\n  _.register(\n    procedure =  myapp.procedure.echo ) {\n    invocation = \n      invocation.args.map( args = \n        Payload(args)\n      )})  A (future of) session can be mapped to a (future of) registration by just invoking the  register  method. It is a curried method with two parameter lists.  // as defined by Akka Wamp\ndef register(procedure: Uri)(handler: InvocationHandler)  The first parameter list accepts  procedure  as documented for the  Register  message constructor. The second parameter list accepts a callback function of type  InvocationHandler .", 
            "title": "Register procedures"
        }, 
        {
            "location": "/client/future/rpc/#invocation-handlers", 
            "text": "// as defined by Akka Wamp\ntype InvocationHandler = (Invocation) =  Future[Payload]  The invocation handler is a function that transforms an invocation to a (future of) output payload. The invocation comes with an input payload whose content can be lazily parsed as input arguments.  // handler for  myapp.procedure.sum \nval handler: InvocationHandler = { invocation = \n  invocation.kwargs.map { kwargs = \n    val arg0 = kwargs( 0 ).asInstanceOf[Int]\n    val arg1 = kwargs( 1 ).asInstanceOf[Int]\n    Payload(List(arg0 + arg1))\n  }}  Arguments can be received from the incoming payload and replied back as documented in the  Payload Handling  section.", 
            "title": "Invocation handlers"
        }, 
        {
            "location": "/client/future/rpc/#recover", 
            "text": "You can either recover or  \"give up\"  when the (future of) registration fails. To recover from failures (such as  SessionException  thrown when the procedure has been already registered by some other callee or when the session turns out to be closed) you can compose  recoverWith  to attempt registering the procedure with a different name or to attempt another session (maybe to a fallback realm):  val registration = session.flatMap(\n  _.register( myapp.procedure.sum )(handler)\n  .recoverWith { \n    case ex: SessionException =  session.flatMap(\n      _.register( myapp.procedure.sum.renamed )(handler)\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  session.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/rpc/#unregister-procedures", 
            "text": "import akka.wamp.messages._\n\nval unregisterd: Future[Unregisterd] = session.flatMap(\n    _.unregister( myapp.procedure.sum )\n  )", 
            "title": "Unregister procedures"
        }, 
        {
            "location": "/client/future/rpc/#recover_1", 
            "text": "TBD", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/rpc/#call-procedures", 
            "text": "Once you got a caller session as documented in the  Session Handling  section, you can finally call a procedure:  // val session = ... \n\nval result: Future[Result] = session.flatMap(\n  _.call(\n    procedure =  myapp.procedure.sum ,\n    args = List(2, 4, 8, 12))\n)\n\nval data: Future[List[Any]] = result.flatMap(\n  _.data\n)  Arguments can be received from the resulting payload as documented in the  Payload Handling  section.", 
            "title": "Call procedures"
        }, 
        {
            "location": "/client/future/rpc/#recover_2", 
            "text": "TBD", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/payload/", 
            "text": "Payload Handling\n\n\nWAMP messages, formatted as textual JSON or binary MsgPack, are transmitted by an underlying transport like WebSocket or RawTCP. Messages are all made of few headers and an optional payload. \n\n\nframe2                  frame1                             \n.-------------.        .-------------,---------.    \n| payload ... |  --\n   | ... payload | headers |  --\n  \n'-------------'        '-------------`---------'     \n\n\n\n\nThe payload contains application data either as a list or as a dictionary of arguments. The payload is always at the end of the message and for some applications (such a BigData or Multimedia Streaming applications), it could be of such a big size that some transports have to split messages in frames.\n\n\nReceive payloads\n\n\nAkka Wamp provides efficient deserializers, implemented using streaming technologies, which do not eagerly parse the contents of incoming payloads but rather return lazy structures to defer parsing to the very last moment.  That lazy structures in question are implemented internally as \nLazyTextPayload\n and \nLazyBinaryPayload\n types.\n\n\n,-------------.  holds     ,-----------.\n|PayloadHolder|----------\n|  Payload  |\n`-------------'            `-----+-----'\n                                 ^\n                                 | inherits\n                   .-------------+-------------. \n                   |                           |\n           ,-------+-------.          ,--------+--------.\n           |LazyTextPayload|          |LazyBinaryPayload|\n           `---------------'          `-----------------'\n\n\n\n\nIncoming messages that can hold a lazy payload are summarized by the following table alongside the client role that receives them: \n\n\n\n\n\n\n\n\nMessage\n\n\nReceiver\n\n\nHandler\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nSubscriber\n\n\nEventHandler\n\n\n\n\n\n\nInvocation\n\n\nCallee\n\n\nInvocationHandler\n\n\n\n\n\n\nResult\n\n\nCaller\n\n\n\n\n\n\n\n\n\n\nAccess parsed data/arguments\n\n\nYou can let Akka Wamp lazily parse the content of incoming payloads on behalf of your client. Your subscriber, callee or caller can access data/arguments parsed by Akka Wamp as (future of) Scala collections of arbitrary types but deserialized with default data type bindings. \n\n\nFor example, a subscriber client can access parsed event data as follows:\n\n\nval handler: EventHandler = { event =\n\n  val data: Future[List[Any] = event.data\n  val kwdata: Future[Map[String, Any]] = event.kwdata\n\n  // ...\n}\n\n\n\n\nSimilarly, a callee client can access parsed invocation arguments as follows:\n\n\nval handler: InvocationHandler = { invocation =\n\n  val args: Future[List[Any] = invocation.args\n  val kwargs: Future[Map[String, Any]] = invocation.kwargs\n\n  // ...\n}\n\n\n\n\nDefault data type bindings\n\n\nBy default, Akka Wamp makes use of either the embedded \nJackson JSON Parser\n (for textual data) or the embedded \nMsgPack Parser\n (for binary data) and deserializes incoming data/arguments to Scala collection whose values match the following data type bindings:\n\n\n\n\n\n\n\n\nJSON\n\n\nMsgPack\n\n\nScala\n\n\n\n\n\n\n\n\n\n\nstring\n\n\n\n\njava.lang.\nString\n\n\n\n\n\n\nnumber\n\n\n\n\njava.lang.\nInteger\n, java.lang.\nLong\n, java.lang.\nDouble\n\n\n\n\n\n\nobject\n\n\n\n\nscala.collection.immutable.\nMap[String, _]\n\n\n\n\n\n\narray\n\n\n\n\nscala.collection.immutable.\nList[_]\n\n\n\n\n\n\ntrue\n\n\n\n\njava.lang.\nBoolean\n\n\n\n\n\n\nfalse\n\n\n\n\njava.lang.\nBoolean\n\n\n\n\n\n\nnull\n\n\n\n\nscala.\nNone\n\n\n\n\n\n\n\n\nCustom data type bindings\n\n\nTBD\n\n\nAccess unparsed content\n\n\n\n\nWARNING\n\nThis is an experimental feature that has not been released yet!\n\n\n\n\nYour clients (either of role subscriber, callee or caller) can access incoming unparsed payload content by consuming an Akka Stream source. It comes in handy for those applications exchanging huge amount of data. But bear in mind that you will be put in charge of parsing payload content appropriately:\n\n\nimport akka.stream.scaladsl._\nimport akka.wamp.serialization._\n\nval handler: EventHandler = { event =\n\n  event.payload match {\n    case payload: BinaryPayload =\n\n      log.warn(\nUnexpected binaray payload\n)\n\n    case payload: TextPayload =\n\n      val source: Source[String] = payload.source\n      // ... consume/parse the Akka Stream source ...\n      ()\n  }\n  // ...\n}\n\n\n\n\nYou can match the payload against \nTextPayload\n or \nBinaryPayload\n, get its Akka Stream source, then create whatever Akka Stream graph you need (composing flows and sink) and finally run the stream to parse the payload contents at your best convenience.\n\n\nExamples\n\n\nTBD\n\n\nJSON\n\n\nTBD\n\n\nYAML\n\n\nTBD\n\n\nMsgPack\n\n\nTBD\n\n\nApache Avro\n\n\nTBD\n\n\nSend payloads\n\n\nTBD", 
            "title": "Payload Handling"
        }, 
        {
            "location": "/client/future/payload/#payload-handling", 
            "text": "WAMP messages, formatted as textual JSON or binary MsgPack, are transmitted by an underlying transport like WebSocket or RawTCP. Messages are all made of few headers and an optional payload.   frame2                  frame1                             \n.-------------.        .-------------,---------.    \n| payload ... |  --    | ... payload | headers |  --   \n'-------------'        '-------------`---------'       The payload contains application data either as a list or as a dictionary of arguments. The payload is always at the end of the message and for some applications (such a BigData or Multimedia Streaming applications), it could be of such a big size that some transports have to split messages in frames.", 
            "title": "Payload Handling"
        }, 
        {
            "location": "/client/future/payload/#receive-payloads", 
            "text": "Akka Wamp provides efficient deserializers, implemented using streaming technologies, which do not eagerly parse the contents of incoming payloads but rather return lazy structures to defer parsing to the very last moment.  That lazy structures in question are implemented internally as  LazyTextPayload  and  LazyBinaryPayload  types.  ,-------------.  holds     ,-----------.\n|PayloadHolder|---------- |  Payload  |\n`-------------'            `-----+-----'\n                                 ^\n                                 | inherits\n                   .-------------+-------------. \n                   |                           |\n           ,-------+-------.          ,--------+--------.\n           |LazyTextPayload|          |LazyBinaryPayload|\n           `---------------'          `-----------------'  Incoming messages that can hold a lazy payload are summarized by the following table alongside the client role that receives them:      Message  Receiver  Handler      Event  Subscriber  EventHandler    Invocation  Callee  InvocationHandler    Result  Caller", 
            "title": "Receive payloads"
        }, 
        {
            "location": "/client/future/payload/#access-parsed-dataarguments", 
            "text": "You can let Akka Wamp lazily parse the content of incoming payloads on behalf of your client. Your subscriber, callee or caller can access data/arguments parsed by Akka Wamp as (future of) Scala collections of arbitrary types but deserialized with default data type bindings.   For example, a subscriber client can access parsed event data as follows:  val handler: EventHandler = { event = \n  val data: Future[List[Any] = event.data\n  val kwdata: Future[Map[String, Any]] = event.kwdata\n\n  // ...\n}  Similarly, a callee client can access parsed invocation arguments as follows:  val handler: InvocationHandler = { invocation = \n  val args: Future[List[Any] = invocation.args\n  val kwargs: Future[Map[String, Any]] = invocation.kwargs\n\n  // ...\n}", 
            "title": "Access parsed data/arguments"
        }, 
        {
            "location": "/client/future/payload/#default-data-type-bindings", 
            "text": "By default, Akka Wamp makes use of either the embedded  Jackson JSON Parser  (for textual data) or the embedded  MsgPack Parser  (for binary data) and deserializes incoming data/arguments to Scala collection whose values match the following data type bindings:     JSON  MsgPack  Scala      string   java.lang. String    number   java.lang. Integer , java.lang. Long , java.lang. Double    object   scala.collection.immutable. Map[String, _]    array   scala.collection.immutable. List[_]    true   java.lang. Boolean    false   java.lang. Boolean    null   scala. None", 
            "title": "Default data type bindings"
        }, 
        {
            "location": "/client/future/payload/#custom-data-type-bindings", 
            "text": "TBD", 
            "title": "Custom data type bindings"
        }, 
        {
            "location": "/client/future/payload/#access-unparsed-content", 
            "text": "WARNING \nThis is an experimental feature that has not been released yet!   Your clients (either of role subscriber, callee or caller) can access incoming unparsed payload content by consuming an Akka Stream source. It comes in handy for those applications exchanging huge amount of data. But bear in mind that you will be put in charge of parsing payload content appropriately:  import akka.stream.scaladsl._\nimport akka.wamp.serialization._\n\nval handler: EventHandler = { event = \n  event.payload match {\n    case payload: BinaryPayload = \n      log.warn( Unexpected binaray payload )\n\n    case payload: TextPayload = \n      val source: Source[String] = payload.source\n      // ... consume/parse the Akka Stream source ...\n      ()\n  }\n  // ...\n}  You can match the payload against  TextPayload  or  BinaryPayload , get its Akka Stream source, then create whatever Akka Stream graph you need (composing flows and sink) and finally run the stream to parse the payload contents at your best convenience.", 
            "title": "Access unparsed content"
        }, 
        {
            "location": "/client/future/payload/#examples", 
            "text": "TBD", 
            "title": "Examples"
        }, 
        {
            "location": "/client/future/payload/#json", 
            "text": "TBD", 
            "title": "JSON"
        }, 
        {
            "location": "/client/future/payload/#yaml", 
            "text": "TBD", 
            "title": "YAML"
        }, 
        {
            "location": "/client/future/payload/#msgpack", 
            "text": "TBD", 
            "title": "MsgPack"
        }, 
        {
            "location": "/client/future/payload/#apache-avro", 
            "text": "TBD", 
            "title": "Apache Avro"
        }, 
        {
            "location": "/client/future/payload/#send-payloads", 
            "text": "TBD", 
            "title": "Send payloads"
        }, 
        {
            "location": "/client/stream/", 
            "text": "Stream based API\n\n\nTBD", 
            "title": "Stream based API"
        }, 
        {
            "location": "/client/stream/#stream-based-api", 
            "text": "TBD", 
            "title": "Stream based API"
        }, 
        {
            "location": "/client/config/", 
            "text": "Configuration\n\n\nakka {\n  wamp {\n    client {\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # The boolean switch to disconnect those peers that send \n      # offending messages (e.g. not deserializable or causing\n      # session failures)\n      #\n      # By default, offending messages are just dropped and \n      # the router resumes processing next incoming messages\n      #\n      disconnect-offending-peers = false\n    }\n  }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/client/config/#configuration", 
            "text": "akka {\n  wamp {\n    client {\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # The boolean switch to disconnect those peers that send \n      # offending messages (e.g. not deserializable or causing\n      # session failures)\n      #\n      # By default, offending messages are just dropped and \n      # the router resumes processing next incoming messages\n      #\n      disconnect-offending-peers = false\n    }\n  }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/messages/", 
            "text": "Messages\n\n\nTBD \n\n\nSession Handling\n\n\n   ,------.                                    ,------.\n   | Peer |                                    | Peer |\n   `--+---'                                    `--+---'\n      |               TCP established             |\n      |\n-----------------------------------------\n|\n      |                                           |\n      |               TLS established             |\n      |+\n---------------------------------------\n+|\n      |+                                         +|\n      |+           WebSocket established         +|\n      |+|\n-------------------------------------\n|+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|                                       |+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|                                       |+|\n      |+|           WebSocket closed            |+|\n      |+|\n-------------------------------------\n|+|\n      |+                                         +|\n      |+              TLS closed                 +|\n      |+\n---------------------------------------\n+|\n      |                                           |\n      |               TCP closed                  |\n      |\n-----------------------------------------\n|\n      |                                           |\n   ,--+---.                                    ,--+---.\n   | Peer |                                    | Peer |\n   `------'                                    `------'\n\n\n\n\n\n\nConnect\n\n\nIt is the message you send to the Akka IO entry point to establish a WAMP connection to a router. It can be constructed passing the following parameters:\n\n\n\n\n\n\nclient\n\n  It is your client actor reference to which messages from the remote router are delivered while the connection is established.\n\n\n\n\n\n\nurl\n\n  It is the \nURL\n to the remote router. By default Akka Wamp makes use of \nws://127.0.0.1:8080/ws\n and it currently supports the following protocols:\n\n\n\n\n\n\nws\n\n    It is the WebSocket protocol.\n\n\n\n\n\n\nsubprotocol\n\n  It is the \nsubprotocol\n you wish to negotiate with the remote router.\n\n\n\n\n\n\nExamples:\n\n\nIO(Wamp) ! Connect(client)\nIO(Wamp) ! Connect(client, url = \nws://router.host.net:8080/path/to/ws\n)\nIO(Wamp) ! Connect(client, subprotocol = \nwamp.2.mgspack\n)\n\n\n\n\n\n\nHello\n\n\nIt is the message you send to the transport to request a new session being opened with the given realm attached plus additional details. It can be constructed passing the following parameters:\n\n\n\n\n\n\nrealm\n\n  It is the realm identifier given as \nURI\n. By default, Akka Wamp sends \nakka.wamp.realm\n\n\n\n\n\n\ndetails\n\n   It is a dictionary of additional details. By default, Akka Wamp makes a dictionary with all possible client roles its supports:\n\n\n\n\nsubscriber\n\n\npublisher\n\n\n\n\n\n\n\n\nExamples:\n\n\nconnection ! Hello()\nconnection ! Hello(\nmyapp.realm\n)\nconnection ! Hello(details = Dict().withRoles(\nsubscriber\n))\nconnection ! Hello(\nmyapp.realm\n, Dict().withRoles(\npublisher\n))\n\n\n\n\n\n\nAbort\n\n\nTBD\n\n\n\n\nWelcome\n\n\nIt is the message you receive from the remote router upon session opening. It can be deconstructed (via Scala pattern matching) to the following parameters:\n\n\n\n\n\n\nsessionId\n\n  It is the session identifier as generated by the remote router.\n\n\n\n\n\n\ndetails\n\n  It is a dictionary with additional details (for example the remote router agent identifier)\n\n\n\n\n\n\nExamples:\n\n\nval sessionId: Long = _\n\ndef receive: Receive = {\n  case Welcome(sessionId, details) =\n\n    log info s\nSession $sessionId opened with $details\n\n    this.sessionId = sessionId\n    context become opened\n}\n\ndef opened: Receive = {\n  case Goodbye =\n\n    this.sessionId = 0\n\n  // case ...  \n}\n\n\n\n\n\n\nGoodbye\n\n\nIt is the message either you send to the transport or receive from the remote router to request session closing. It can be constructed (deconstructed) with (to) the following parameters:\n\n\n\n\n\n\nreason\n\n  It is the reason identifier given as \nsession close URI\n. By default, Akka Wamp sends \nwamp.error.close_realm\n\n\n\n\n\n\ndetails\n\n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.\n\n\n\n\n\n\nSome sending snippets are:\n\n\nconnection ! Goodbye()\nconnection ! Goodbye(\nwamp.error.system_shutdown\n)\nconnection ! Goodbye(details = Dict().withEntry(reason -\n \nSerious error occured!\n))\n\n\n\n\nA receiving snippet is:\n\n\ndef opened: Receive = {\n  case Goodbye(reason, details) =\n\n    log warn s\nRouter closed session because of $details\n\n    connection ! Goodbye(\nwamp.error.goodbye_and_out\n)\n    if (reason != \nwamp.error.system_shutdown\n)\n      // why not requesting a new session \n      connection ! Hello\n    else\n      IO(Wamp) ! Connect(self)\n}\n\n\n\n\n\n\nNOTE: there's an open [issue#242]((https://github.com/wamp-proto/wamp-proto/issues/242) on GitHub about the \nGoodbye\n message to warn you that some remote routers could decide to disconnect the transport in addition to close the session. If that happens the you'll be forced to reconnect.\n\n\n\n\n\n\nError\n\n\nTBD\n\n\nPublish Subscribe\n\n\n\n\nSubscribe\n\n\nIt is the message you send to the transport to subscribe to a topic. It can be constructed passing the following parameters:\n\n\n\n\n\n\nrequestId\n\n  It is the request identifier you have to generate in \n\"session scope\"\n. AkkaWamp provides you with a \nScope.Session\n trait you can mixin to invoke \nnextId()\n\n\n\n\n\n\ntopic\n\n  It is the topic URI you want to subscribe to.\n\n\n\n\n\n\noptions\n\n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.\n\n\n\n\n\n\nExamples:\n\n\nconnection ! Subscribe(requestId = 34, \nmyapp.tick.topic\n)\n\n\n\n\n\n\nSubscribed\n\n\nTBD\n\n\n\n\nPublish\n\n\nIt is the message you send to the transport to publish an event. It can be constructed passing the following parameters:\n\n\n\n\n\n\nrequestId\n\n  It is the request identifier you have to generate in \n\"session scope\"\n. AkkaWamp provides you with a \nScope.Session\n trait you can mixin to invoke \nnextId()\n\n\n\n\n\n\ntopic\n\n  It is the topic URI to which you wish to publish to\n\n\n\n\n\n\npayload\n\n  It is the (option of) payload you could provide to send data arguments. By default, Akka Wamp sends none but you could create some as documented in the \nPayload\n section below.\n\n\n\n\n\n\noptions\n\n  It is a dictionary of additional details (for example with the \n\"acknowledge\" -\n true\n entry if you wish to receive the \nPublished\n message from the router). By default, Akka Wamp sends an empty dictionary.\n\n\n\n\n\n\nExamples:\n\n\nconnection ! Publish(requestId = 34, \nmyapp.tick.topic\n)\n\nval list = Payload(\npaolo\n, 40, true)\nconnection ! Publish(nextId(), \nmyapp.topic1\n, Some(list))\n\nval mixed = Payload(\npaolo\n, \nage\n-\n40, true)\nconnection ! Publish(nextId(), \nmyapp.topic1\n, Some(mixed))\n\nconnection ! Publish(89, \nmyapp.topic3\n, options = Dict().withAcknowledge(true))\n\n\n\n\n\n\nEvent\n\n\nIt is the message you receive from the remote router each time other clients have published to the same topics you subscribed to. It can be deconstructed (via Scala pattern matching) to the following parameters:\n\n\n\n\n\n\nsubscriptionId\n  \n\n  It is the subscription identifier you could use to figure out which topic the event has been fired for.\n\n\n\n\n\n\npublicationId\n  \n\n   It is the publication identifier generated by the remote router in global scope.\n\n\n\n\n\n\npayload\n  \n\n  It is the (option of) payload with data arguments you could read as documented in the \nPayload\n section below.\n\n\n\n\n\n\ndetails\n\n  It is a dictionary with additional details.\n\n\n\n\n\n\nExamples:\n\n\nval subscriptionId: Long = _\n\ndef opened: Receive = {\n  case Event(subscriptionId, publicationId, None, details) =\n\n    log debug s\nEvent received for subscription $subscriptionId\n\n\n  case Event(_, _, Some(payload), _) =\n\n    log debug s\nEvent receive with payload $payload\n\n}\n\n\n\n\nRemote Procedure Calls\n\n\n\n\nRegister\n\n\nTBD\n\n\n\n\nCall\n\n\nTBD\n\n\n\n\nInvoke\n\n\nTBD\n\n\n\n\nYield\n\n\nTBD\n\n\n\n\nResult\n\n\nTBD", 
            "title": "Messages"
        }, 
        {
            "location": "/messages/#messages", 
            "text": "TBD", 
            "title": "Messages"
        }, 
        {
            "location": "/messages/#session-handling", 
            "text": ",------.                                    ,------.\n   | Peer |                                    | Peer |\n   `--+---'                                    `--+---'\n      |               TCP established             |\n      | ----------------------------------------- |\n      |                                           |\n      |               TLS established             |\n      |+ --------------------------------------- +|\n      |+                                         +|\n      |+           WebSocket established         +|\n      |+| ------------------------------------- |+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+ ----------------------------------- +|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+ ----------------------------------- +|+|\n      |+|                                       |+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+ ----------------------------------- +|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+ ----------------------------------- +|+|\n      |+|                                       |+|\n      |+|           WebSocket closed            |+|\n      |+| ------------------------------------- |+|\n      |+                                         +|\n      |+              TLS closed                 +|\n      |+ --------------------------------------- +|\n      |                                           |\n      |               TCP closed                  |\n      | ----------------------------------------- |\n      |                                           |\n   ,--+---.                                    ,--+---.\n   | Peer |                                    | Peer |\n   `------'                                    `------'", 
            "title": "Session Handling"
        }, 
        {
            "location": "/messages/#connect", 
            "text": "It is the message you send to the Akka IO entry point to establish a WAMP connection to a router. It can be constructed passing the following parameters:    client \n  It is your client actor reference to which messages from the remote router are delivered while the connection is established.    url \n  It is the  URL  to the remote router. By default Akka Wamp makes use of  ws://127.0.0.1:8080/ws  and it currently supports the following protocols:    ws \n    It is the WebSocket protocol.    subprotocol \n  It is the  subprotocol  you wish to negotiate with the remote router.    Examples:  IO(Wamp) ! Connect(client)\nIO(Wamp) ! Connect(client, url =  ws://router.host.net:8080/path/to/ws )\nIO(Wamp) ! Connect(client, subprotocol =  wamp.2.mgspack )", 
            "title": "Connect"
        }, 
        {
            "location": "/messages/#hello", 
            "text": "It is the message you send to the transport to request a new session being opened with the given realm attached plus additional details. It can be constructed passing the following parameters:    realm \n  It is the realm identifier given as  URI . By default, Akka Wamp sends  akka.wamp.realm    details \n   It is a dictionary of additional details. By default, Akka Wamp makes a dictionary with all possible client roles its supports:   subscriber  publisher     Examples:  connection ! Hello()\nconnection ! Hello( myapp.realm )\nconnection ! Hello(details = Dict().withRoles( subscriber ))\nconnection ! Hello( myapp.realm , Dict().withRoles( publisher ))", 
            "title": "Hello"
        }, 
        {
            "location": "/messages/#abort", 
            "text": "TBD", 
            "title": "Abort"
        }, 
        {
            "location": "/messages/#welcome", 
            "text": "It is the message you receive from the remote router upon session opening. It can be deconstructed (via Scala pattern matching) to the following parameters:    sessionId \n  It is the session identifier as generated by the remote router.    details \n  It is a dictionary with additional details (for example the remote router agent identifier)    Examples:  val sessionId: Long = _\n\ndef receive: Receive = {\n  case Welcome(sessionId, details) = \n    log info s Session $sessionId opened with $details \n    this.sessionId = sessionId\n    context become opened\n}\n\ndef opened: Receive = {\n  case Goodbye = \n    this.sessionId = 0\n\n  // case ...  \n}", 
            "title": "Welcome"
        }, 
        {
            "location": "/messages/#goodbye", 
            "text": "It is the message either you send to the transport or receive from the remote router to request session closing. It can be constructed (deconstructed) with (to) the following parameters:    reason \n  It is the reason identifier given as  session close URI . By default, Akka Wamp sends  wamp.error.close_realm    details \n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.    Some sending snippets are:  connection ! Goodbye()\nconnection ! Goodbye( wamp.error.system_shutdown )\nconnection ! Goodbye(details = Dict().withEntry(reason -   Serious error occured! ))  A receiving snippet is:  def opened: Receive = {\n  case Goodbye(reason, details) = \n    log warn s Router closed session because of $details \n    connection ! Goodbye( wamp.error.goodbye_and_out )\n    if (reason !=  wamp.error.system_shutdown )\n      // why not requesting a new session \n      connection ! Hello\n    else\n      IO(Wamp) ! Connect(self)\n}   NOTE: there's an open [issue#242]((https://github.com/wamp-proto/wamp-proto/issues/242) on GitHub about the  Goodbye  message to warn you that some remote routers could decide to disconnect the transport in addition to close the session. If that happens the you'll be forced to reconnect.", 
            "title": "Goodbye"
        }, 
        {
            "location": "/messages/#error", 
            "text": "TBD", 
            "title": "Error"
        }, 
        {
            "location": "/messages/#publish-subscribe", 
            "text": "", 
            "title": "Publish Subscribe"
        }, 
        {
            "location": "/messages/#subscribe", 
            "text": "It is the message you send to the transport to subscribe to a topic. It can be constructed passing the following parameters:    requestId \n  It is the request identifier you have to generate in  \"session scope\" . AkkaWamp provides you with a  Scope.Session  trait you can mixin to invoke  nextId()    topic \n  It is the topic URI you want to subscribe to.    options \n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.    Examples:  connection ! Subscribe(requestId = 34,  myapp.tick.topic )", 
            "title": "Subscribe"
        }, 
        {
            "location": "/messages/#subscribed", 
            "text": "TBD", 
            "title": "Subscribed"
        }, 
        {
            "location": "/messages/#publish", 
            "text": "It is the message you send to the transport to publish an event. It can be constructed passing the following parameters:    requestId \n  It is the request identifier you have to generate in  \"session scope\" . AkkaWamp provides you with a  Scope.Session  trait you can mixin to invoke  nextId()    topic \n  It is the topic URI to which you wish to publish to    payload \n  It is the (option of) payload you could provide to send data arguments. By default, Akka Wamp sends none but you could create some as documented in the  Payload  section below.    options \n  It is a dictionary of additional details (for example with the  \"acknowledge\" -  true  entry if you wish to receive the  Published  message from the router). By default, Akka Wamp sends an empty dictionary.    Examples:  connection ! Publish(requestId = 34,  myapp.tick.topic )\n\nval list = Payload( paolo , 40, true)\nconnection ! Publish(nextId(),  myapp.topic1 , Some(list))\n\nval mixed = Payload( paolo ,  age - 40, true)\nconnection ! Publish(nextId(),  myapp.topic1 , Some(mixed))\n\nconnection ! Publish(89,  myapp.topic3 , options = Dict().withAcknowledge(true))", 
            "title": "Publish"
        }, 
        {
            "location": "/messages/#event", 
            "text": "It is the message you receive from the remote router each time other clients have published to the same topics you subscribed to. It can be deconstructed (via Scala pattern matching) to the following parameters:    subscriptionId    \n  It is the subscription identifier you could use to figure out which topic the event has been fired for.    publicationId    \n   It is the publication identifier generated by the remote router in global scope.    payload    \n  It is the (option of) payload with data arguments you could read as documented in the  Payload  section below.    details \n  It is a dictionary with additional details.    Examples:  val subscriptionId: Long = _\n\ndef opened: Receive = {\n  case Event(subscriptionId, publicationId, None, details) = \n    log debug s Event received for subscription $subscriptionId \n\n  case Event(_, _, Some(payload), _) = \n    log debug s Event receive with payload $payload \n}", 
            "title": "Event"
        }, 
        {
            "location": "/messages/#remote-procedure-calls", 
            "text": "", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/messages/#register", 
            "text": "TBD", 
            "title": "Register"
        }, 
        {
            "location": "/messages/#call", 
            "text": "TBD", 
            "title": "Call"
        }, 
        {
            "location": "/messages/#invoke", 
            "text": "TBD", 
            "title": "Invoke"
        }, 
        {
            "location": "/messages/#yield", 
            "text": "TBD", 
            "title": "Yield"
        }, 
        {
            "location": "/messages/#result", 
            "text": "TBD", 
            "title": "Result"
        }
    ]
}