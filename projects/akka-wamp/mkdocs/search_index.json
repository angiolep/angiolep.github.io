{
    "docs": [
        {
            "location": "/", 
            "text": "Akka Wamp\n\n\n \n \n \n\n\nAkka Wamp is a WAMP - \nWeb Application Messaging Protocol\n implementation written in \nScala\n with \nAkka\n\n\nEasy to download as \nSBT\n library dependency.\n\n\nlibraryDependencies ++= Seq(\n  \ncom.github.angiolep\n % \nakka-wamp_2.11\n % \n0.12.0\n\n)  \n\n\n\n\nClient APIs\n\n\nConnect to a router, open a session, subscribe a topic, receive events, register a procedure and call it in few lines of Scala!\n\n\n\n\nActor, Future and Stream based APIs\n\n\nWell documented and rich examples\n\n\nLazy and pluggable deserialization\n\n\n\n\nPlease, read the docs for \nfurther details\n\n\nimport scala.concurrent.duration._\nimport akka.wamp.client._\n\nobject MyClientApp extends App {\n  val client = Client()\n  implicit val ec = client.executionContext\n\n  for {\n    session \n- client.\n      openSession(\n        url = \nws://localhost:8080/ws\n,\n        realm = \nmyapp.realm\n)\n    publication \n- session.\n      publish(\n        topic = \nmyapp.topic.people\n,\n        ack = true,\n        argskw = Map(\nname\n-\npaolo\n, \nage\n-\n40))\n    subscription \n- session.\n      subscribe(\n        topic = \nmyapp.topic.any\n,\n        (event) =\n event.data.map(println))\n    registration \n- session.\n      register(\n        procedure = \nmyapp.procedure.sum\n, \n        handler = (a: Int, b: Int) =\n a + b)\n    result \n- session.\n      call(\n        procedure = \nmyapp.procedure.multiply\n,\n        args = List(3, 8)\n      )\n  } \n  yield ()\n}\n\n\n\n\nRouter\n\n\n\n\nAkka Wamp provides you with a router that can be either embedded into your application or launched as standalone server process.\n\n\nDownload the latest router version, extract, configure and run it as standalone application:\n\n\ncurl https://dl.bintray.com/angiolep/universal/akka-wamp-0.12.0.tgz\ntar xvfz akka-wamp-0.12.0.tar.gz\ncd akka-wamp-0.12.0\nvim ./conf/application.conf\n./bin/akka-wamp -Dakka.loglevel=DEBUG\n\n\n\n\nPlease, read the docs for \nfurther details\n\n\nLimitations\n\n\n\n\nScala 2.11 only (no older Scala and no Java yet)\n\n\nWebSocket transport only (no raw TCP and no SSL/TLS yet) \n\n\nProvide WAMP Basic Profile only (no Advanced Profile yet)\n\n\nProvide JSON serialization only (no MsgPack yet)\n\n\n\n\nChangelog\n\n\nPlease, read \nCHANGELOG.md\n\n\nContributing\n\n\nPlease, read \nCONTRIBUTING.md\n\n\nLicence\n\n\nThis software comes with \nApache License 2.0\n\n\nDisclaimer\n\n\n\n\nThis SOFTWARE PRODUCT is provided by THE PROVIDER \"as is\" and \"with all faults.\" THE PROVIDER makes no representations or warranties of any kind concerning the safety, suitability, lack of viruses, inaccuracies, typographical errors, or other harmful components of this SOFTWARE PRODUCT. There are inherent dangers in the use of any software, and you are solely responsible for determining whether this SOFTWARE PRODUCT is compatible with your equipment and other software installed on your equipment. You are also solely responsible for the protection of your equipment and backup of your data, and THE PROVIDER will not be liable for any damages you may suffer in connection with using, modifying, or distributing this SOFTWARE PRODUCT", 
            "title": "Home"
        }, 
        {
            "location": "/#akka-wamp", 
            "text": "Akka Wamp is a WAMP -  Web Application Messaging Protocol  implementation written in  Scala  with  Akka  Easy to download as  SBT  library dependency.  libraryDependencies ++= Seq(\n   com.github.angiolep  %  akka-wamp_2.11  %  0.12.0 \n)", 
            "title": "Akka Wamp"
        }, 
        {
            "location": "/#client-apis", 
            "text": "Connect to a router, open a session, subscribe a topic, receive events, register a procedure and call it in few lines of Scala!   Actor, Future and Stream based APIs  Well documented and rich examples  Lazy and pluggable deserialization   Please, read the docs for  further details  import scala.concurrent.duration._\nimport akka.wamp.client._\n\nobject MyClientApp extends App {\n  val client = Client()\n  implicit val ec = client.executionContext\n\n  for {\n    session  - client.\n      openSession(\n        url =  ws://localhost:8080/ws ,\n        realm =  myapp.realm )\n    publication  - session.\n      publish(\n        topic =  myapp.topic.people ,\n        ack = true,\n        argskw = Map( name - paolo ,  age - 40))\n    subscription  - session.\n      subscribe(\n        topic =  myapp.topic.any ,\n        (event) =  event.data.map(println))\n    registration  - session.\n      register(\n        procedure =  myapp.procedure.sum , \n        handler = (a: Int, b: Int) =  a + b)\n    result  - session.\n      call(\n        procedure =  myapp.procedure.multiply ,\n        args = List(3, 8)\n      )\n  } \n  yield ()\n}", 
            "title": "Client APIs"
        }, 
        {
            "location": "/#router", 
            "text": "Akka Wamp provides you with a router that can be either embedded into your application or launched as standalone server process.  Download the latest router version, extract, configure and run it as standalone application:  curl https://dl.bintray.com/angiolep/universal/akka-wamp-0.12.0.tgz\ntar xvfz akka-wamp-0.12.0.tar.gz\ncd akka-wamp-0.12.0\nvim ./conf/application.conf\n./bin/akka-wamp -Dakka.loglevel=DEBUG  Please, read the docs for  further details", 
            "title": "Router"
        }, 
        {
            "location": "/#limitations", 
            "text": "Scala 2.11 only (no older Scala and no Java yet)  WebSocket transport only (no raw TCP and no SSL/TLS yet)   Provide WAMP Basic Profile only (no Advanced Profile yet)  Provide JSON serialization only (no MsgPack yet)", 
            "title": "Limitations"
        }, 
        {
            "location": "/#changelog", 
            "text": "Please, read  CHANGELOG.md", 
            "title": "Changelog"
        }, 
        {
            "location": "/#contributing", 
            "text": "Please, read  CONTRIBUTING.md", 
            "title": "Contributing"
        }, 
        {
            "location": "/#licence", 
            "text": "This software comes with  Apache License 2.0", 
            "title": "Licence"
        }, 
        {
            "location": "/#disclaimer", 
            "text": "This SOFTWARE PRODUCT is provided by THE PROVIDER \"as is\" and \"with all faults.\" THE PROVIDER makes no representations or warranties of any kind concerning the safety, suitability, lack of viruses, inaccuracies, typographical errors, or other harmful components of this SOFTWARE PRODUCT. There are inherent dangers in the use of any software, and you are solely responsible for determining whether this SOFTWARE PRODUCT is compatible with your equipment and other software installed on your equipment. You are also solely responsible for the protection of your equipment and backup of your data, and THE PROVIDER will not be liable for any damages you may suffer in connection with using, modifying, or distributing this SOFTWARE PRODUCT", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/router/overview/", 
            "text": "Router\n\n\nAkka Wamp provides you with a router that can be either launched as standalone server process or embedded into your application.\n\n\nIt provides:\n\n\n\n\nBoth \nbroker\n (for publish/subscribe) and \ndealer\n (for routed remote procedure calls) roles.\n\n\nJSON serialization\n\n\n\n\nStandalone router\n\n\n\n\nDownload the latest router version, extract, configure and run it as standalone application:\n\n\ncurl https://dl.bintray.com/angiolep/universal/akka-wamp-0.12.0.tgz\ntar xvfz akka-wamp-0.12.0.tar.gz\ncd akka-wamp-0.12.0\nvim ./conf/application.conf\n./bin/akka-wamp -Dakka.loglevel=DEBUG\n\n\n\n\nEmbedded router\n\n\nMake your build depend on the latest version of akka-wamp: \n\n\nscalaVersion := \n2.11.8\n\n\nlibraryDependencies ++= Seq(\n  \ncom.github.angiolep\n %% \nakka-wamp\n % \n0.12.0\n\n  // ...\n)\n\n\n\n\nCreate the Akka \nActorSystem\n and the Akka Wamp \nRouter\n actor as follows:\n\n\nimport akka.actor._\nimport akka.wamp.router._\n\nimplicit val system = ActorSystem(\nmyapp\n)\nval router = system.actorOf(Router.props(), \nrouter\n)\n\n\n\n\n\n\nBind/Unbind\n\n\nTo bind a router a router to a configured transport, just send a \nBind\n command to the \nIO(Wamp)\n extension manager:\n\n\nimport akka.wamp._\nimport akka.wamp.messages._\n\nval manager = IO(Wamp)\nmanager ! Bind(router, transport = \ndefault\n)\n\n\n\n\nThe manager will spawn a new transport listener for the given transport name as per above configuration. Your application actor, the binder, will be notified by the manager about the outcome of the command:\n\n\noverride def receive: Receive = {\n  case signal @ CommandFailed(cmd, ex) =\n\n    log.warning(s\n$cmd failed because of $ex\n)\n\n  case signal @ Bound(listener, url) =\n\n    log.debug(s\n$listener bound to $url\n)\n    // ...\n    // listener ! Unbind\n} \n\n\n\n\nOn successfully bound, you'll be sent the actor reference of the transport listener actor and the URL which that actor is bound to. If you wish to unbind the listener, just the send an \nUnbind\n message.\n\n\nlistener ! Unbind\n\n\n\n\nExamples\n\n\n\n\nEmbeddedRouterApp\n\n\n\n\nLimitations\n\n\nTBD", 
            "title": "Overview"
        }, 
        {
            "location": "/router/overview/#router", 
            "text": "Akka Wamp provides you with a router that can be either launched as standalone server process or embedded into your application.  It provides:   Both  broker  (for publish/subscribe) and  dealer  (for routed remote procedure calls) roles.  JSON serialization", 
            "title": "Router"
        }, 
        {
            "location": "/router/overview/#standalone-router", 
            "text": "Download the latest router version, extract, configure and run it as standalone application:  curl https://dl.bintray.com/angiolep/universal/akka-wamp-0.12.0.tgz\ntar xvfz akka-wamp-0.12.0.tar.gz\ncd akka-wamp-0.12.0\nvim ./conf/application.conf\n./bin/akka-wamp -Dakka.loglevel=DEBUG", 
            "title": "Standalone router"
        }, 
        {
            "location": "/router/overview/#embedded-router", 
            "text": "Make your build depend on the latest version of akka-wamp:   scalaVersion :=  2.11.8 \n\nlibraryDependencies ++= Seq(\n   com.github.angiolep  %%  akka-wamp  %  0.12.0 \n  // ...\n)  Create the Akka  ActorSystem  and the Akka Wamp  Router  actor as follows:  import akka.actor._\nimport akka.wamp.router._\n\nimplicit val system = ActorSystem( myapp )\nval router = system.actorOf(Router.props(),  router )", 
            "title": "Embedded router"
        }, 
        {
            "location": "/router/overview/#bindunbind", 
            "text": "To bind a router a router to a configured transport, just send a  Bind  command to the  IO(Wamp)  extension manager:  import akka.wamp._\nimport akka.wamp.messages._\n\nval manager = IO(Wamp)\nmanager ! Bind(router, transport =  default )  The manager will spawn a new transport listener for the given transport name as per above configuration. Your application actor, the binder, will be notified by the manager about the outcome of the command:  override def receive: Receive = {\n  case signal @ CommandFailed(cmd, ex) = \n    log.warning(s $cmd failed because of $ex )\n\n  case signal @ Bound(listener, url) = \n    log.debug(s $listener bound to $url )\n    // ...\n    // listener ! Unbind\n}   On successfully bound, you'll be sent the actor reference of the transport listener actor and the URL which that actor is bound to. If you wish to unbind the listener, just the send an  Unbind  message.  listener ! Unbind", 
            "title": "Bind/Unbind"
        }, 
        {
            "location": "/router/overview/#examples", 
            "text": "EmbeddedRouterApp", 
            "title": "Examples"
        }, 
        {
            "location": "/router/overview/#limitations", 
            "text": "TBD", 
            "title": "Limitations"
        }, 
        {
            "location": "/router/config/", 
            "text": "Router configuration\n\n\nEither the embedded or the standalone router can be configured by applying the following settings:\n\n\nakka {\n  wamp {\n    router {\n      # The local filesystem path the router will serve static\n      # web resources (such as HTML docs) out of\n      #\n      webroot = \n./webroot\n\n\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # The boolean switch to NOT automatically create realms \n      # if they don't exist yet.\n      #\n      abort-unknown-realms = false\n\n      # The boolean switch to drop offending messages (e.g. \n      # not deserializable or against the protocol).\n      #\n      # By default, offending messages will cause session to be\n      # closed and transport to be disconnected. Set this switch on \n      # if you prefer to rather drop offending messages and resume.\n      #\n      drop-offending-messages = false\n\n      # Named transport configurations\n      #\n      transport {\n        default {\n          # Transport protocol can be:\n          #\n          # - tcp\n          #     Raw TCP\n          # - tsl\n          #     Transport Secure Layer\n          # - ws    \n          #     WebSocket \n          # - wss\n          #     WebSocket over TLS\n          #\n          protocol = \nws\n\n\n          # Transport subprotocol can be:\n          # \n          # - wamp.2.json\n          #   JSON Javascript Object Notation\n          #\n          # - wamp.2.msgpack\n          #   Message Pack\n          #\n          subprotocol = \nwamp.2.json\n\n\n          # The TCP interface to bind to\n          #\n          iface = \n127.0.0.1\n\n\n          # The TCP port number (between 0 and 65536) to bind to.\n          # If set to 0 the first available randome port number \n          # will be chosen\n          #\n          port = 8080\n\n          # (Only for \nws\n and \nwss\n protocols)\n          # The URL path incoming HTTP Upgrade request are expected \n          # to be addressed to\n          #\n          wspath = \nrouter\n\n        },\n        #secure {\n        #  protocol = \nwss\n\n        #  iface = \n127.0.0.1\n\n        #  port = 8443\n        #  path = \nrouter\n\n        #}\n      }\n    }\n  }\n}\n\n\n\n\nAbove default settings can be overridden\n\n\n\n\n(for standalone router) by editing the \nconf/application.conf\n file\n\n\n(for embedded router) by providing an \napplication.conf\n file on the classpath,\n\n\nby passing system properties to the Java interpreter (e.g. \n-Dakka.wamp.router.transport.default.port=9090\n)\n\n\n\n\nLogging\n\n\nakka {\n  #\n  # Following are already set by akka-wamp as default\n  #\n  loggers = [\nakka.event.slf4j.Slf4jLogger\n]\n  loglevel = \nINFO\n\n  logging-filter = \nakka.event.slf4j.Slf4jLoggingFilter\n\n\n  # Just provide an additional logback.xml file on the classpath \n  # so to customize your loggers, appenders and patterns\n  # \n}\n\n\n\n\nSecurity\n\n\nTBD", 
            "title": "Configuration"
        }, 
        {
            "location": "/router/config/#router-configuration", 
            "text": "Either the embedded or the standalone router can be configured by applying the following settings:  akka {\n  wamp {\n    router {\n      # The local filesystem path the router will serve static\n      # web resources (such as HTML docs) out of\n      #\n      webroot =  ./webroot \n\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # The boolean switch to NOT automatically create realms \n      # if they don't exist yet.\n      #\n      abort-unknown-realms = false\n\n      # The boolean switch to drop offending messages (e.g. \n      # not deserializable or against the protocol).\n      #\n      # By default, offending messages will cause session to be\n      # closed and transport to be disconnected. Set this switch on \n      # if you prefer to rather drop offending messages and resume.\n      #\n      drop-offending-messages = false\n\n      # Named transport configurations\n      #\n      transport {\n        default {\n          # Transport protocol can be:\n          #\n          # - tcp\n          #     Raw TCP\n          # - tsl\n          #     Transport Secure Layer\n          # - ws    \n          #     WebSocket \n          # - wss\n          #     WebSocket over TLS\n          #\n          protocol =  ws \n\n          # Transport subprotocol can be:\n          # \n          # - wamp.2.json\n          #   JSON Javascript Object Notation\n          #\n          # - wamp.2.msgpack\n          #   Message Pack\n          #\n          subprotocol =  wamp.2.json \n\n          # The TCP interface to bind to\n          #\n          iface =  127.0.0.1 \n\n          # The TCP port number (between 0 and 65536) to bind to.\n          # If set to 0 the first available randome port number \n          # will be chosen\n          #\n          port = 8080\n\n          # (Only for  ws  and  wss  protocols)\n          # The URL path incoming HTTP Upgrade request are expected \n          # to be addressed to\n          #\n          wspath =  router \n        },\n        #secure {\n        #  protocol =  wss \n        #  iface =  127.0.0.1 \n        #  port = 8443\n        #  path =  router \n        #}\n      }\n    }\n  }\n}  Above default settings can be overridden   (for standalone router) by editing the  conf/application.conf  file  (for embedded router) by providing an  application.conf  file on the classpath,  by passing system properties to the Java interpreter (e.g.  -Dakka.wamp.router.transport.default.port=9090 )", 
            "title": "Router configuration"
        }, 
        {
            "location": "/router/config/#logging", 
            "text": "akka {\n  #\n  # Following are already set by akka-wamp as default\n  #\n  loggers = [ akka.event.slf4j.Slf4jLogger ]\n  loglevel =  INFO \n  logging-filter =  akka.event.slf4j.Slf4jLoggingFilter \n\n  # Just provide an additional logback.xml file on the classpath \n  # so to customize your loggers, appenders and patterns\n  # \n}", 
            "title": "Logging"
        }, 
        {
            "location": "/router/config/#security", 
            "text": "TBD", 
            "title": "Security"
        }, 
        {
            "location": "/client/overview/", 
            "text": "Client APIs overview\n\n\nAkka Wamp provides you with three alternative Client APIs:\n\n\n\n\nActor based API\n\n\nFuture based API\n\n\nStream based API\n\n\n\n\nThey all provide easy ways to establish transports and sessions, publish and subscribe topics, register and call procedures. They differ in terms of which \nAkka\n abstractions you'd prefer to use in writing client applications.\n\n\nTransports and Sessions\n\n\nThe WAMP protocol specification states:\n\n\n\n\nWAMP implementations MAY choose to tie the lifetime of the underlying transport connection for a WAMP connection to that of a WAMP session, i.e. establish a new transport-layer connection as part of each new session establishment.\n\n\n\n\nThat's how many WAMP implementations (such AutobahnJS, Crossbar.io, Jawampa, etc.) actually work. But, as you read the spec a little bit further:\n\n\n\n\nThey MAY equally choose to allow re-use of a transport connection, allowing subsequent WAMP sessions to be established using the same transport connection.\n\n\n\n\nThat's how Akka Wamp works, instead! \n\n\nAkka Wamp handles transports and sessions as separate entities, each with their own lifecycle. That gives you a way to keep the transport connection established whatever happens to the session opened onto it. So that, if the session gets closed you can still reuse the transport connection to open a subsequent new session.\n\n\nFor example, using the future based API, you could:\n\n\nval transport = client.connect()\nval session1 = transport.flatMap(_.openSession())\n// ... \nsession1.close()\n\n// reuse the same transport to open subsequent sessions\nval session2 = conn.flatMap(_.openSession())\n// ... \nsession2.close()\n\n// finally disconnect the transport\ntransport.disconnect()\n\n\n\n\nRead on\n\n\n\n\nActor based API\n\n\nFuture based API\n\n\nStream based API", 
            "title": "Overview"
        }, 
        {
            "location": "/client/overview/#client-apis-overview", 
            "text": "Akka Wamp provides you with three alternative Client APIs:   Actor based API  Future based API  Stream based API   They all provide easy ways to establish transports and sessions, publish and subscribe topics, register and call procedures. They differ in terms of which  Akka  abstractions you'd prefer to use in writing client applications.", 
            "title": "Client APIs overview"
        }, 
        {
            "location": "/client/overview/#transports-and-sessions", 
            "text": "The WAMP protocol specification states:   WAMP implementations MAY choose to tie the lifetime of the underlying transport connection for a WAMP connection to that of a WAMP session, i.e. establish a new transport-layer connection as part of each new session establishment.   That's how many WAMP implementations (such AutobahnJS, Crossbar.io, Jawampa, etc.) actually work. But, as you read the spec a little bit further:   They MAY equally choose to allow re-use of a transport connection, allowing subsequent WAMP sessions to be established using the same transport connection.   That's how Akka Wamp works, instead!   Akka Wamp handles transports and sessions as separate entities, each with their own lifecycle. That gives you a way to keep the transport connection established whatever happens to the session opened onto it. So that, if the session gets closed you can still reuse the transport connection to open a subsequent new session.  For example, using the future based API, you could:  val transport = client.connect()\nval session1 = transport.flatMap(_.openSession())\n// ... \nsession1.close()\n\n// reuse the same transport to open subsequent sessions\nval session2 = conn.flatMap(_.openSession())\n// ... \nsession2.close()\n\n// finally disconnect the transport\ntransport.disconnect()", 
            "title": "Transports and Sessions"
        }, 
        {
            "location": "/client/overview/#read-on", 
            "text": "Actor based API  Future based API  Stream based API", 
            "title": "Read on"
        }, 
        {
            "location": "/client/actor/overview/", 
            "text": "Actor based API overview\n\n\nAkka Wamp Actor based API provides you with a \nAkka I/O\n extension driver named \nWamp\n.\n\n\nThe Akka I/O API is completely \nAkka Actor\n based, meaning that all operations are implemented with message passing instead of direct method calls. \n\n\nSo it means, you client application spawns a client actor able to \n\n\n\n\n\n\nsend\n messages such as \nConnect\n, \nHello\n, \nSubscribe\n, \nRegister\n, \nCall\n, \nGoodbye\n, \nDisconnect\n to perform all of the WAMP relevant actions such as connecting a transport, opening a session, subscribing to a topic, registering or calling a procedure, closing a session and disconnecting a transport,\n\n\n\n\n\n\nand \nreceive\n messages such as \nConnected\n, \nAbort\n, \nWelcome\n, \nSubscribed\n, \nRegistered\n, \nResult\n, \nGoodbye\n, \nDisconnected\n to react to all of the WAMP signals such as router connected, session aborted or opened, topic subscribed, procedure registered, result, session closed and transport disconnected.  \n\n\n\n\n\n\nobject ActorBasedClientApp extends App {\n  import akka.actor._\n  import akka.io._\n  import akka.wamp._\n  import akka.wamp.client._\n  import akka.wamp.messages._\n\n  implicit val system = ActorSystem()\n  system.actorOf(Props[Client])\n\n  class Client extends Actor with ClientUtils {\n    val manager = IO(Wamp)\n    manager ! Connect(\nws://localhost:8080/ws\n, \nwamp.2.json\n)\n\n    var transport: ActorRef = _\n    var requestId: Id = _\n    var subscriptionId: Id = _\n\n    override def receive = {\n      case Connected(t) =\n\n        transport = t\n        transport ! Hello(\nmyapp.realm\n)\n\n      case Welcome(_, _) =\n\n        requestId = nextRequestId()\n        transport ! Subscribe(requestId, Dict(), \nmyapp.topic1\n)\n        transport ! Publish(nextRequestId(), Dict(), \nmyapp.topic2\n)\n\n      case Subscribed(reqId, subId)  =\n\n        if (reqId == requestId) \n          subscriptionId = subId\n\n      case Event(subId, _, _, payload) =\n\n        if (subId == subscriptionId)\n          payload.parsed.map(p =\n println(p.args))\n    }\n  }\n}\n\n\n\n\nRead on\n\n\n\n\nSession Handling\n\n\nPublish Subscribe\n\n\nRemote Procedure Call\n\n\nPayload Handling", 
            "title": "Overview"
        }, 
        {
            "location": "/client/actor/overview/#actor-based-api-overview", 
            "text": "Akka Wamp Actor based API provides you with a  Akka I/O  extension driver named  Wamp .  The Akka I/O API is completely  Akka Actor  based, meaning that all operations are implemented with message passing instead of direct method calls.   So it means, you client application spawns a client actor able to     send  messages such as  Connect ,  Hello ,  Subscribe ,  Register ,  Call ,  Goodbye ,  Disconnect  to perform all of the WAMP relevant actions such as connecting a transport, opening a session, subscribing to a topic, registering or calling a procedure, closing a session and disconnecting a transport,    and  receive  messages such as  Connected ,  Abort ,  Welcome ,  Subscribed ,  Registered ,  Result ,  Goodbye ,  Disconnected  to react to all of the WAMP signals such as router connected, session aborted or opened, topic subscribed, procedure registered, result, session closed and transport disconnected.      object ActorBasedClientApp extends App {\n  import akka.actor._\n  import akka.io._\n  import akka.wamp._\n  import akka.wamp.client._\n  import akka.wamp.messages._\n\n  implicit val system = ActorSystem()\n  system.actorOf(Props[Client])\n\n  class Client extends Actor with ClientUtils {\n    val manager = IO(Wamp)\n    manager ! Connect( ws://localhost:8080/ws ,  wamp.2.json )\n\n    var transport: ActorRef = _\n    var requestId: Id = _\n    var subscriptionId: Id = _\n\n    override def receive = {\n      case Connected(t) = \n        transport = t\n        transport ! Hello( myapp.realm )\n\n      case Welcome(_, _) = \n        requestId = nextRequestId()\n        transport ! Subscribe(requestId, Dict(),  myapp.topic1 )\n        transport ! Publish(nextRequestId(), Dict(),  myapp.topic2 )\n\n      case Subscribed(reqId, subId)  = \n        if (reqId == requestId) \n          subscriptionId = subId\n\n      case Event(subId, _, _, payload) = \n        if (subId == subscriptionId)\n          payload.parsed.map(p =  println(p.args))\n    }\n  }\n}", 
            "title": "Actor based API overview"
        }, 
        {
            "location": "/client/actor/overview/#read-on", 
            "text": "Session Handling  Publish Subscribe  Remote Procedure Call  Payload Handling", 
            "title": "Read on"
        }, 
        {
            "location": "/client/actor/session/", 
            "text": "Session Handling\n\n\nAccess the manager, connect transports and open sessions.\n\n\nimport akka.actor._\nimport akka.io._\nimport akka.wamp._\nimport akka.wamp.client._\nimport akka.wamp.messages._\n\nimplicit val system = ActorSystem()\nsystem.actorOf(Props[Client])\n\nclass Client extends Actor with ClientUtils {\n  val manager = IO(Wamp)\n  manager ! Connect(\nws://localhost:8080/ws\n, \nwamp.2.json\n)\n\n  var transport: ActorRef = _\n  val sessionId: Id = _\n\n  override def receive = {\n    case Connected(handler) =\n\n      transport = handler\n      println(\ntransport connected\n)\n      transport ! Hello(\nmyapp.realm\n)\n\n    case Welcome(sid, details) =\n\n      sessionId = sid  \n      println(s\nsession $sid opened\n)\n  }\n}\n\n\n\n\nAccess the manager\n\n\nAkka Wamp provides you with a \nAkka I/O\n extension driver named \nWamp\n.\n\n\nEvery Akka I/O driver (TCP, UDP, WAMP, etc.) has a special actor, called \nextension manager\n, that serves as an entry point for the API. The manager for a particular driver is accessible through the \nIO\n entry point. For example the following code looks up the WAMP manager and returns its ActorRef:\n\n\nimplicit val system = ActorSystem()\nval manager = IO(Wamp)\n\n\n\n\nConnect transports\n\n\nThe manager receives I/O command messages and instantiates worker actors in response. The worker actors present themselves to the API user in the reply to the command that was sent. \n\n\nmanager ! Connect(\nws://localhost:8080/ws\n, \nwamp.2.json\n)\n\n\n\n\nFor example, after a \nConnect\n command is sent to the manager, the manager creates a worker actor representing the transport handler. All operations related to the WAMP protocol can be invoked by sending messages to the transport handler. The handler which announces itself via a \nConnected\n signal.\n\n\nvar transport: ActorRef = _\n\noverride def receive = {\n  case Connected(handler) =\n\n    transport = handler\n    println(\ntransport connected\n)\n    // ...\n}\n\n\n\n\nRepeated attempts\n\n\nYou could repeatedly attempt a transport connection if the last failed:\n\n\nval connect = Connect(\nws://localhost:8080/ws\n, \nwamp.2.json\n)\n\noverride def receive = {\n  // ...\n\n  case CommandFailed(cmd: Connect, _ =\n\n    scheduler.scheduleOne(1 second, manager, connect)\n\n  // ...  \n}\n\n\n\n\nOpen sessions\n\n\ntransport ! Hello(\nmyapp.realm\n)\n\n\n\n\nTBD\n\n\nval sessionId: Id = 0L\n\noverride def receive = {\n  // ...\n  case Welcome(sid, details) =\n\n    sessionId = sid  \n    println(s\nsession $sid opened\n)\n    // ...\n}\n\n\n\n\nClose sessions\n\n\ntransport ! Goodbye()\n\n\n\n\nTBD\n\n\noverride def receive = {\n  // ...\n  case Goodbye(details, reason) =\n\n    sessionId = 0L\n    // ...\n}\n\n\n\n\nDisconnect transports\n\n\ntransport ! Disconnect\n\n\n\n\nTBD\n\n\noverride def receive = {\n  // ...\n  case Disconnected =\n\n    // ...\n}", 
            "title": "Session Handling"
        }, 
        {
            "location": "/client/actor/session/#session-handling", 
            "text": "Access the manager, connect transports and open sessions.  import akka.actor._\nimport akka.io._\nimport akka.wamp._\nimport akka.wamp.client._\nimport akka.wamp.messages._\n\nimplicit val system = ActorSystem()\nsystem.actorOf(Props[Client])\n\nclass Client extends Actor with ClientUtils {\n  val manager = IO(Wamp)\n  manager ! Connect( ws://localhost:8080/ws ,  wamp.2.json )\n\n  var transport: ActorRef = _\n  val sessionId: Id = _\n\n  override def receive = {\n    case Connected(handler) = \n      transport = handler\n      println( transport connected )\n      transport ! Hello( myapp.realm )\n\n    case Welcome(sid, details) = \n      sessionId = sid  \n      println(s session $sid opened )\n  }\n}", 
            "title": "Session Handling"
        }, 
        {
            "location": "/client/actor/session/#access-the-manager", 
            "text": "Akka Wamp provides you with a  Akka I/O  extension driver named  Wamp .  Every Akka I/O driver (TCP, UDP, WAMP, etc.) has a special actor, called  extension manager , that serves as an entry point for the API. The manager for a particular driver is accessible through the  IO  entry point. For example the following code looks up the WAMP manager and returns its ActorRef:  implicit val system = ActorSystem()\nval manager = IO(Wamp)", 
            "title": "Access the manager"
        }, 
        {
            "location": "/client/actor/session/#connect-transports", 
            "text": "The manager receives I/O command messages and instantiates worker actors in response. The worker actors present themselves to the API user in the reply to the command that was sent.   manager ! Connect( ws://localhost:8080/ws ,  wamp.2.json )  For example, after a  Connect  command is sent to the manager, the manager creates a worker actor representing the transport handler. All operations related to the WAMP protocol can be invoked by sending messages to the transport handler. The handler which announces itself via a  Connected  signal.  var transport: ActorRef = _\n\noverride def receive = {\n  case Connected(handler) = \n    transport = handler\n    println( transport connected )\n    // ...\n}", 
            "title": "Connect transports"
        }, 
        {
            "location": "/client/actor/session/#repeated-attempts", 
            "text": "You could repeatedly attempt a transport connection if the last failed:  val connect = Connect( ws://localhost:8080/ws ,  wamp.2.json )\n\noverride def receive = {\n  // ...\n\n  case CommandFailed(cmd: Connect, _ = \n    scheduler.scheduleOne(1 second, manager, connect)\n\n  // ...  \n}", 
            "title": "Repeated attempts"
        }, 
        {
            "location": "/client/actor/session/#open-sessions", 
            "text": "transport ! Hello( myapp.realm )  TBD  val sessionId: Id = 0L\n\noverride def receive = {\n  // ...\n  case Welcome(sid, details) = \n    sessionId = sid  \n    println(s session $sid opened )\n    // ...\n}", 
            "title": "Open sessions"
        }, 
        {
            "location": "/client/actor/session/#close-sessions", 
            "text": "transport ! Goodbye()  TBD  override def receive = {\n  // ...\n  case Goodbye(details, reason) = \n    sessionId = 0L\n    // ...\n}", 
            "title": "Close sessions"
        }, 
        {
            "location": "/client/actor/session/#disconnect-transports", 
            "text": "transport ! Disconnect  TBD  override def receive = {\n  // ...\n  case Disconnected = \n    // ...\n}", 
            "title": "Disconnect transports"
        }, 
        {
            "location": "/client/future/overview/", 
            "text": "Future based API overview\n\n\nAkka Wamp provides you with an \nAkka Future\n based API, built on top of \nAkka Wamp Actor based API\n, to let you write your client with a higher level API.\n\n\nAll operations are implemented with direct method calls which return futures you can compose in monadic expressions or in Scala for comprehension.\n\n\nobject FutureBasedClientApp extends App {\n\n  import akka.wamp.client._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  for {\n    session \n- client\n      .openSession(\n        url = \nws://localhost:8080/ws\n,\n        subprotocol = \nwamp.2.json\n,\n        realm = \ndefault.realm\n,\n        roles = Set(\nsubscriber\n))\n    subscription \n- session\n      .subscribe(\n        topic = \nmyapp.topic1\n)(\n        event =\n\n          event.data.map(println)\n      )\n    publication \n- session\n      .publish(\n        topic = \nmyapp.topic2\n,\n        ack = false,\n        kwdata = Map(\nname\n-\npaolo\n, \nage\n-\n40)\n      )\n  } yield ()\n}\n\n\n\n\nRead on\n\n\n\n\nSession Handling\n\n\nPublish Subscribe\n\n\nRemote Procedure Call\n\n\nPayload Handling", 
            "title": "Overview"
        }, 
        {
            "location": "/client/future/overview/#future-based-api-overview", 
            "text": "Akka Wamp provides you with an  Akka Future  based API, built on top of  Akka Wamp Actor based API , to let you write your client with a higher level API.  All operations are implemented with direct method calls which return futures you can compose in monadic expressions or in Scala for comprehension.  object FutureBasedClientApp extends App {\n\n  import akka.wamp.client._\n  val client = Client()\n\n  implicit val ec = client.executionContext\n\n  for {\n    session  - client\n      .openSession(\n        url =  ws://localhost:8080/ws ,\n        subprotocol =  wamp.2.json ,\n        realm =  default.realm ,\n        roles = Set( subscriber ))\n    subscription  - session\n      .subscribe(\n        topic =  myapp.topic1 )(\n        event = \n          event.data.map(println)\n      )\n    publication  - session\n      .publish(\n        topic =  myapp.topic2 ,\n        ack = false,\n        kwdata = Map( name - paolo ,  age - 40)\n      )\n  } yield ()\n}", 
            "title": "Future based API overview"
        }, 
        {
            "location": "/client/future/overview/#read-on", 
            "text": "Session Handling  Publish Subscribe  Remote Procedure Call  Payload Handling", 
            "title": "Read on"
        }, 
        {
            "location": "/client/future/session/", 
            "text": "Session Handling\n\n\nCreate clients, connect transport and open sessions.\n\n\nimport akka.wamp.client._\nval client = Client(\nmyapp\n)\n\nimplicit val ec = client.executionContext\n\nval session = client\n  .connect(\n    url = \nws://localhost:8080/ws\n,\n    subprotocol = \nwamp.2.json\n)\n  .openSession(\n    realm = \ndefault.realm\n,\n    roles = Set(\nsubscriber\n)\n  )\n}\n\n\n\n\nCreate clients\n\n\nimport akka.wamp.client._\nval client = Client(\nmyapp\n)\n\n\n\n\nCreate the client by invoking the \nClient\n companion object factory method with the following arguments\n\n\n\n\n\n\nname\n\n   The unique name of the client (default is \n\"default\"\n)\n\n\n\n\n\n\nconfig\n\n   The configuration object (default is \nConfigFactory.load()\n as per standard behaviour of \nTypeSafe Config\n)\n\n\n\n\n\n\nThe factory method creates an \nAkka ActorSystem\n named after the client and configured with the given configuration object. \n\n\nConfiguration\n\n\nTBD\n\n\nMultiplicity\n\n\nIn Akka Wamp, one client can connect many transports but each transport can open only one session.\n\n\n    ,--------.  1      0..n  ,------------.  1      0..1  ,---------. \n    | Client |  -----------  | Transport  |  -----------  | Session | \n    `--------'               `------------'               `---------'\n\n\n\n\nBear in mind that, though you could create as many client as you wish, its actor system is a heavyweight structure that allocates 1..n threads. So you're advised to create \none client per logical application\n.\n\n\nExecution context\n\n\nAll of the operation provided by client, transport and session objects always return futures. In order to execute callbacks and operations, futures need something called an \nExecutionContext\n. You can import the existing \nclient.executionContext\n as implicit in scope:\n\n\nimplicit val ec = client.executionContext\n\n\n\n\nor create your own.\n\n\nConnect transports\n\n\nimport scala.concurrent.Future\n\nval transport1: Future[Transport] = client\n  .connect(\n    url = \nws://localhost:8080/ws\n,\n    subprotocol = \nwamp.2.json\n)\n\nval transport2 = client\n  .connect(\n    url = \nwss://secure.host.net:443/wamp\n,\n    subprotocol = \nwamp.2.msgpack\n)    \n\n\n\n\nConnect a transport by just invoking the client \nconnect()\n method which accepts \nurl\n and \nsubprotocol\n arguments as documented for the \nConnect\n message constructor. \n\n\nYou can establish as many connections as you wish (to the same or to different routers) as the connect method returns a distinct (future of) connection.\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) connection fails. To recover from failures (such as \nTransportException\n thrown when router cannot accept connection) you can compose \nrecoverWith\n to attempt another connection (maybe to a fallback router):\n\n\nval transport1: Future[Transport] = client\n  .connect(\n    url = \nws://localhost:8080/ws\n)\n  .recoverWith { \n    case ex: TransportException =\n client\n      .connect(\n        url = \nws://fallback.host.net:9999/path\n)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that terminates the application:\n\n\ntransport.onFailure {\n  case ex: Throwable =\n\n    client.terminate().map(_ =\n System.exit(-1))\n}\n\n\n\n\nOpen sessions\n\n\nval session1: Future[Session] = conn1.flatMap(\n  _.openSession(\n    realm = \ndefault.realm\n,\n    roles = Set(\nsubscriber\n)))\n\nval session2 = conn2.flatMap(\n  _.openSession(\n    roles = Set(\npublisher\n, \ncallee\n)))    \n\n\n\n\nA (future of) transport can be mapped to a (future of) session by just invoking the \nopenSession()\n method which accepts \nrealm\n and \nroles\n arguments as documented for the \nHello\n message constructor. \n\n\nYou can open only one session per transport. Therefore, if you wish to open a second session then you must establish a second transport (using the same client or a different one).\n\n\nShortcut\n\n\nYou can shortcut transport connection and session opening in one single concise statement by invoking \nopenSession()\n on the client rather than on the transport:\n\n\nval session: Future[Session] = client\n  .openSession(\n    url = \nws://some.host.net:8080/ws\n,\n    subprotocol = \nwamp.2.json\n,\n    realm = \ndefault.realm\n,\n    roles = Set(\nsubscriber\n, \ncaller\n))\n\n\n\n\nThe client \nopenSession()\n method accepts all of the \nurl\n, \nsubprotocol\n, \nrealm\n and \ndetails\n arguments mentioned above. It connects a new transport and opens a new session each time you call it.\n\n\nRecover\n\n\nYou can either recover or \n\"give up\"\n when the (future of) session fails. To recover from failures (such as \nAbortException\n thrown when router doesn't attach to a realm) you can compose \nrecoverWith\n to attempt another session opening (maybe to a fallback realm):\n\n\nval session: Future[Session] = client\n  .openSession(\n    realm = \ndefault.realm\n)\n  .recoverWith { \n    case ex: AbortException =\n client\n      .openSession(\n        realm = \nfallback.realm\n)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\nsession.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nClose sessions\n\n\nval transport: Future[Transport] = session.close()\n\n\n\n\nDisconnect transports\n\n\nval d: Future[Disconnected] = transport.disconnect()\n\n\n\n\nTerminate clients\n\n\nval t: Future[Terminated] = client.terminate()", 
            "title": "Session Handling"
        }, 
        {
            "location": "/client/future/session/#session-handling", 
            "text": "Create clients, connect transport and open sessions.  import akka.wamp.client._\nval client = Client( myapp )\n\nimplicit val ec = client.executionContext\n\nval session = client\n  .connect(\n    url =  ws://localhost:8080/ws ,\n    subprotocol =  wamp.2.json )\n  .openSession(\n    realm =  default.realm ,\n    roles = Set( subscriber )\n  )\n}", 
            "title": "Session Handling"
        }, 
        {
            "location": "/client/future/session/#create-clients", 
            "text": "import akka.wamp.client._\nval client = Client( myapp )  Create the client by invoking the  Client  companion object factory method with the following arguments    name \n   The unique name of the client (default is  \"default\" )    config \n   The configuration object (default is  ConfigFactory.load()  as per standard behaviour of  TypeSafe Config )    The factory method creates an  Akka ActorSystem  named after the client and configured with the given configuration object.", 
            "title": "Create clients"
        }, 
        {
            "location": "/client/future/session/#configuration", 
            "text": "TBD", 
            "title": "Configuration"
        }, 
        {
            "location": "/client/future/session/#multiplicity", 
            "text": "In Akka Wamp, one client can connect many transports but each transport can open only one session.      ,--------.  1      0..n  ,------------.  1      0..1  ,---------. \n    | Client |  -----------  | Transport  |  -----------  | Session | \n    `--------'               `------------'               `---------'  Bear in mind that, though you could create as many client as you wish, its actor system is a heavyweight structure that allocates 1..n threads. So you're advised to create  one client per logical application .", 
            "title": "Multiplicity"
        }, 
        {
            "location": "/client/future/session/#execution-context", 
            "text": "All of the operation provided by client, transport and session objects always return futures. In order to execute callbacks and operations, futures need something called an  ExecutionContext . You can import the existing  client.executionContext  as implicit in scope:  implicit val ec = client.executionContext  or create your own.", 
            "title": "Execution context"
        }, 
        {
            "location": "/client/future/session/#connect-transports", 
            "text": "import scala.concurrent.Future\n\nval transport1: Future[Transport] = client\n  .connect(\n    url =  ws://localhost:8080/ws ,\n    subprotocol =  wamp.2.json )\n\nval transport2 = client\n  .connect(\n    url =  wss://secure.host.net:443/wamp ,\n    subprotocol =  wamp.2.msgpack )      Connect a transport by just invoking the client  connect()  method which accepts  url  and  subprotocol  arguments as documented for the  Connect  message constructor.   You can establish as many connections as you wish (to the same or to different routers) as the connect method returns a distinct (future of) connection.", 
            "title": "Connect transports"
        }, 
        {
            "location": "/client/future/session/#recover", 
            "text": "You can either recover or  \"give up\"  when the (future of) connection fails. To recover from failures (such as  TransportException  thrown when router cannot accept connection) you can compose  recoverWith  to attempt another connection (maybe to a fallback router):  val transport1: Future[Transport] = client\n  .connect(\n    url =  ws://localhost:8080/ws )\n  .recoverWith { \n    case ex: TransportException =  client\n      .connect(\n        url =  ws://fallback.host.net:9999/path )\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that terminates the application:  transport.onFailure {\n  case ex: Throwable = \n    client.terminate().map(_ =  System.exit(-1))\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/session/#open-sessions", 
            "text": "val session1: Future[Session] = conn1.flatMap(\n  _.openSession(\n    realm =  default.realm ,\n    roles = Set( subscriber )))\n\nval session2 = conn2.flatMap(\n  _.openSession(\n    roles = Set( publisher ,  callee )))      A (future of) transport can be mapped to a (future of) session by just invoking the  openSession()  method which accepts  realm  and  roles  arguments as documented for the  Hello  message constructor.   You can open only one session per transport. Therefore, if you wish to open a second session then you must establish a second transport (using the same client or a different one).", 
            "title": "Open sessions"
        }, 
        {
            "location": "/client/future/session/#shortcut", 
            "text": "You can shortcut transport connection and session opening in one single concise statement by invoking  openSession()  on the client rather than on the transport:  val session: Future[Session] = client\n  .openSession(\n    url =  ws://some.host.net:8080/ws ,\n    subprotocol =  wamp.2.json ,\n    realm =  default.realm ,\n    roles = Set( subscriber ,  caller ))  The client  openSession()  method accepts all of the  url ,  subprotocol ,  realm  and  details  arguments mentioned above. It connects a new transport and opens a new session each time you call it.", 
            "title": "Shortcut"
        }, 
        {
            "location": "/client/future/session/#recover_1", 
            "text": "You can either recover or  \"give up\"  when the (future of) session fails. To recover from failures (such as  AbortException  thrown when router doesn't attach to a realm) you can compose  recoverWith  to attempt another session opening (maybe to a fallback realm):  val session: Future[Session] = client\n  .openSession(\n    realm =  default.realm )\n  .recoverWith { \n    case ex: AbortException =  client\n      .openSession(\n        realm =  fallback.realm )\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  session.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover"
        }, 
        {
            "location": "/client/future/session/#close-sessions", 
            "text": "val transport: Future[Transport] = session.close()", 
            "title": "Close sessions"
        }, 
        {
            "location": "/client/future/session/#disconnect-transports", 
            "text": "val d: Future[Disconnected] = transport.disconnect()", 
            "title": "Disconnect transports"
        }, 
        {
            "location": "/client/future/session/#terminate-clients", 
            "text": "val t: Future[Terminated] = client.terminate()", 
            "title": "Terminate clients"
        }, 
        {
            "location": "/client/future/pubsub/", 
            "text": "Publish and Subscribe\n\n\nimport scala.concurrent.duration._\nimport akka.wamp.client._\n\nobject MyClientApp extends App {\n  val client = Client()\n  implicit val ec = client.executionContext\n\n  for {\n    session \n- client\n      .openSession(\n        url = \nws://localhost:8080/ws\n,\n        subprotocol = \nwamp.2.json\n,\n        realm = \ndefault.realm\n,\n        roles = Set(\nsubscriber\n))\n    subscription \n- session\n      .subscribe(\n        topic = \nmyapp.topic.any\n,\n        event =\n event.data.map(println)\n      )\n    publication \n- session\n      .publish(\n        topic = \nmyapp.topic.people\n,\n        ack = false,\n        kwdata = Map(\nname\n-\npaolo\n, \nage\n-\n40)\n      )\n    tickling \n- session\n      .tickle(\n        topic = \nmyapp.topic.ticks\n,\n        interval = 1 second\n      )\n  } yield ()\n}\n\n\n\n\nThe WAMP protocol defines a Publish and Subscribe (PubSub) communication pattern where a client, the subscriber, informs the broker router that it wants to receive events on a topic (i.e., it subscribes to a topic). Another client, a publisher, can then publish events to this topic, and the broker router distributes events to all subscriber.\n\n\n  ,---------.          ,------.             ,----------.\n  |Publisher|          |Broker|             |Subscriber|\n  `----+----'          `--+---'             `----+-----'\n       |                  |                      |\n       |                  |            SUBSCRIBE |\n       |                  \n---------------------|\n       |                  |                      |\n       |                  | SUBSCRIBED           |\n       |                  |---------------------\n\n       |                  |                      |\n       |                  |                      |\n       | PUBLISH          |                      |\n       |-----------------\n                      |\n       |                  |                      |\n       |        PUBLISHED |                      |\n       \n-----------------|                      |\n       |                  |                      |\n       |                  |  EVENT               |\n       |                  |---------------------\n\n       |                  |                      |\n  ,----+----.          ,--+---.             ,----+-----.\n  |Publisher|          |Broker|             |Subscriber|\n  `---------'          `------'             `----------'\n\n\n\n\nSubscribe topics\n\n\nOnce you got a session, you can subscribe to a topic:\n\n\nimport akka.wamp._\nimport akka.wamp.message._\n\n// implicit val executionContext = ...\n// val session = ... \n\nval subscription: Future[Subscription] = session.flatMap(\n  _.subscribe(\n      topic = \nmyapp.topic\n,\n      event =\n {\n        log.info(s\n${event.publicationId}\n)\n        event.data.map(println)\n      })\n\n\n\n\nA (future of) session can be mapped to a (future of) subscription by invoking one of the provided \nsubscribe()\n method.\n\n\n// as defined by Akka Wamp\n\ndef subscribe(topic: Uri, handler: EventHandler)\n\n\n\n\nIt accepts a \ntopic\n as documented for the \nSubscribe\n message and a callback function of type \nEventHandler\n which gets invoked to process each event from the topic. \n\n\nEvent handlers\n\n\n// as defined by Akka Wamp\ntype EventHandler = (Event) =\n Unit\n\n\n\n\nThe event handler is a function with side-effects that transforms an event to \nunit\n (like \nvoid\n for Java). The event comes with an input payload whose content can be lazily parsed as input data. \n\n\n// your event handler\nval handler: EventHandler = { event =\n\n  event.data.map { data =\n\n    println(data)\n  }\n}\n\n\n\n\nReceiving application data is documented in the \nPayload Handling\n section.  \n\n\nMultiple handlers\n\n\nval handler1: EventHandler = { event =\n\n  event.data.map { data =\n\n    println(s\n(1) \n-- $data\n)\n  }\n}\nval handler2: EventHandler = { event =\n\n  event.data.map { data =\n\n    println(s\n(2) \n-- $data\n)\n  }\n}\n\n// let's subscribe them to the same topic! \n\nval subscription1 = session.flatMap(\n  _.subscribe(\n      topic = \nmyapp.topic\n,\n      handler1))\n\nval subscription2 = session.flatMap(\n  _.subscribe(\n      topic = \nmyapp.topic\n,\n      handler2))\n\n\n\n\nYou can subscribe many times to the same topic passing the same or different event handlers. As per WAMP protocol specification, the correspondent subscriptions held by the router will share the same subscription identifier. Therefore, your Akka Wamp client subscriber will: \n\n\n\n\nadd your event handlers in the same set linked to the same subscription identifier,\n\n\ninvoke all of them anytime an event with that subscription identifier is received.\n\n\n\n\nRecover exceptions\n\n\nYou can either recover or \n\"give up\"\n when the (future of) subscription fails. To recover from failures (such as \nSessionException\n thrown when session turns out to be closed) you can compose \nrecoverWith\n to attempt another session opening (maybe to a fallback realm and/or to a fallback topic):\n\n\nval subscription = session.flatMap(\n  _.subscribe(\nmyapp.topic\n, handler)\n  .recoverWith { \n    case ex: SessionException =\n session.flatMap(\n      _.subscribe(\nmyapp.topic.heartbeat\n, handler)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\nsession.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nUnsubscribe topics\n\n\nimport akka.wamp.messages._\n\nval subscription: Future[Subscription] = ...\n\nval unsubscribed: Future[Unsubscribed] = subscription.flatMap(\n  _.unsubscribe()\n)\n\n\n\n\nJust call the \nunsubscribe()\n method on the subscription you want to terminate.\n\n\nMultiple handlers\n\n\nTBD\n\n\nPublish events\n\n\nOnce you got a session, you can publish to a topic:\n\n\nimport akka.Done\nimport akka.wamp.serialization._\n\nval publication: Future[Either[Done, Publication]] = session.flatMap(\n  _.publish(\n      topic = \nmyapp.topic\n,\n      payload = Payload(\npaolo\n, 40, true),\n      ack = true\n  ))\n\n\n\n\nA (future of) session can be mapped to a (future of) either done or publication by invoking the \npublish\n method which accepts \ntopic\n, \nack\n and a \npayload\n arguments as documented for the \nPublish\n message constructor. Sending arguments is documented in the \nPayload Handling\n section.  \n\n\nAcknowledge\n\n\nNote that if you leave \nack\n switched off (as by default) then Akka Wamp will not expect to receive the \nPublished\n message back from the router and the (future of either of) publication or done immediately completes with (left of) \nDone\n. Otherwise, if you switch \nack\n on then the (future of either of) publication or done later completes with (right of) \nPublication\n (if no exception were thrown).\n\n\nYou could pass a callback \nonSuccess\n to better understand what really happens:\n\n\n// ack = true\npublication.onSuccess {\n  case Success(Left(Done)) =\n\n    println(s\nPublication done\n) \n}\n\n// ack = false\npublication.onSuccess {\n  case Success(Right(p)) =\n\n    println(s\nPublished with ${p.publicationId}\n)\n}\n\n\n\n\nRecover exceptions\n\n\nYou can either recover or \n\"give up\"\n when the (future of) publication fails. To recover from failures (such as \nSessionException\n when session turns out to be closed as you try to publish) you can compose \nrecoverWith\n  to attempt another session opening (maybe to a fallback realm and to a fallback topic):\n\n\nval publication = session1.flatMap(_.publish(\nmyapp.topic.ticking\n)\n  .recoverWith { \n    case ex: SessionException =\n\n      for {\n        session2 \n- client.openSession()\n        publication2 \n- session2.publish(\nmyapp.topic.heartbeat\n)\n      }\n      yield publication2\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\npublication.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nTickle\n\n\nYou can easily publish a tick count to a topic with an initial delay and frequency.\n\n\nimport scala.concurrent.duration._\n\nval tickling: Future[Cancelable] = session.flatMap(\n  _.tickle(\n    topic = \nmyapp.topic.ticks\n, \n    delay = Duration.Zero, \n    interval = 1 second)\n  ))", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/client/future/pubsub/#publish-and-subscribe", 
            "text": "import scala.concurrent.duration._\nimport akka.wamp.client._\n\nobject MyClientApp extends App {\n  val client = Client()\n  implicit val ec = client.executionContext\n\n  for {\n    session  - client\n      .openSession(\n        url =  ws://localhost:8080/ws ,\n        subprotocol =  wamp.2.json ,\n        realm =  default.realm ,\n        roles = Set( subscriber ))\n    subscription  - session\n      .subscribe(\n        topic =  myapp.topic.any ,\n        event =  event.data.map(println)\n      )\n    publication  - session\n      .publish(\n        topic =  myapp.topic.people ,\n        ack = false,\n        kwdata = Map( name - paolo ,  age - 40)\n      )\n    tickling  - session\n      .tickle(\n        topic =  myapp.topic.ticks ,\n        interval = 1 second\n      )\n  } yield ()\n}  The WAMP protocol defines a Publish and Subscribe (PubSub) communication pattern where a client, the subscriber, informs the broker router that it wants to receive events on a topic (i.e., it subscribes to a topic). Another client, a publisher, can then publish events to this topic, and the broker router distributes events to all subscriber.    ,---------.          ,------.             ,----------.\n  |Publisher|          |Broker|             |Subscriber|\n  `----+----'          `--+---'             `----+-----'\n       |                  |                      |\n       |                  |            SUBSCRIBE |\n       |                   ---------------------|\n       |                  |                      |\n       |                  | SUBSCRIBED           |\n       |                  |--------------------- \n       |                  |                      |\n       |                  |                      |\n       | PUBLISH          |                      |\n       |-----------------                       |\n       |                  |                      |\n       |        PUBLISHED |                      |\n        -----------------|                      |\n       |                  |                      |\n       |                  |  EVENT               |\n       |                  |--------------------- \n       |                  |                      |\n  ,----+----.          ,--+---.             ,----+-----.\n  |Publisher|          |Broker|             |Subscriber|\n  `---------'          `------'             `----------'", 
            "title": "Publish and Subscribe"
        }, 
        {
            "location": "/client/future/pubsub/#subscribe-topics", 
            "text": "Once you got a session, you can subscribe to a topic:  import akka.wamp._\nimport akka.wamp.message._\n\n// implicit val executionContext = ...\n// val session = ... \n\nval subscription: Future[Subscription] = session.flatMap(\n  _.subscribe(\n      topic =  myapp.topic ,\n      event =  {\n        log.info(s ${event.publicationId} )\n        event.data.map(println)\n      })  A (future of) session can be mapped to a (future of) subscription by invoking one of the provided  subscribe()  method.  // as defined by Akka Wamp\n\ndef subscribe(topic: Uri, handler: EventHandler)  It accepts a  topic  as documented for the  Subscribe  message and a callback function of type  EventHandler  which gets invoked to process each event from the topic.", 
            "title": "Subscribe topics"
        }, 
        {
            "location": "/client/future/pubsub/#event-handlers", 
            "text": "// as defined by Akka Wamp\ntype EventHandler = (Event) =  Unit  The event handler is a function with side-effects that transforms an event to  unit  (like  void  for Java). The event comes with an input payload whose content can be lazily parsed as input data.   // your event handler\nval handler: EventHandler = { event = \n  event.data.map { data = \n    println(data)\n  }\n}  Receiving application data is documented in the  Payload Handling  section.", 
            "title": "Event handlers"
        }, 
        {
            "location": "/client/future/pubsub/#multiple-handlers", 
            "text": "val handler1: EventHandler = { event = \n  event.data.map { data = \n    println(s (1)  -- $data )\n  }\n}\nval handler2: EventHandler = { event = \n  event.data.map { data = \n    println(s (2)  -- $data )\n  }\n}\n\n// let's subscribe them to the same topic! \n\nval subscription1 = session.flatMap(\n  _.subscribe(\n      topic =  myapp.topic ,\n      handler1))\n\nval subscription2 = session.flatMap(\n  _.subscribe(\n      topic =  myapp.topic ,\n      handler2))  You can subscribe many times to the same topic passing the same or different event handlers. As per WAMP protocol specification, the correspondent subscriptions held by the router will share the same subscription identifier. Therefore, your Akka Wamp client subscriber will:    add your event handlers in the same set linked to the same subscription identifier,  invoke all of them anytime an event with that subscription identifier is received.", 
            "title": "Multiple handlers"
        }, 
        {
            "location": "/client/future/pubsub/#recover-exceptions", 
            "text": "You can either recover or  \"give up\"  when the (future of) subscription fails. To recover from failures (such as  SessionException  thrown when session turns out to be closed) you can compose  recoverWith  to attempt another session opening (maybe to a fallback realm and/or to a fallback topic):  val subscription = session.flatMap(\n  _.subscribe( myapp.topic , handler)\n  .recoverWith { \n    case ex: SessionException =  session.flatMap(\n      _.subscribe( myapp.topic.heartbeat , handler)\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  session.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover exceptions"
        }, 
        {
            "location": "/client/future/pubsub/#unsubscribe-topics", 
            "text": "import akka.wamp.messages._\n\nval subscription: Future[Subscription] = ...\n\nval unsubscribed: Future[Unsubscribed] = subscription.flatMap(\n  _.unsubscribe()\n)  Just call the  unsubscribe()  method on the subscription you want to terminate.", 
            "title": "Unsubscribe topics"
        }, 
        {
            "location": "/client/future/pubsub/#multiple-handlers_1", 
            "text": "TBD", 
            "title": "Multiple handlers"
        }, 
        {
            "location": "/client/future/pubsub/#publish-events", 
            "text": "Once you got a session, you can publish to a topic:  import akka.Done\nimport akka.wamp.serialization._\n\nval publication: Future[Either[Done, Publication]] = session.flatMap(\n  _.publish(\n      topic =  myapp.topic ,\n      payload = Payload( paolo , 40, true),\n      ack = true\n  ))  A (future of) session can be mapped to a (future of) either done or publication by invoking the  publish  method which accepts  topic ,  ack  and a  payload  arguments as documented for the  Publish  message constructor. Sending arguments is documented in the  Payload Handling  section.", 
            "title": "Publish events"
        }, 
        {
            "location": "/client/future/pubsub/#acknowledge", 
            "text": "Note that if you leave  ack  switched off (as by default) then Akka Wamp will not expect to receive the  Published  message back from the router and the (future of either of) publication or done immediately completes with (left of)  Done . Otherwise, if you switch  ack  on then the (future of either of) publication or done later completes with (right of)  Publication  (if no exception were thrown).  You could pass a callback  onSuccess  to better understand what really happens:  // ack = true\npublication.onSuccess {\n  case Success(Left(Done)) = \n    println(s Publication done ) \n}\n\n// ack = false\npublication.onSuccess {\n  case Success(Right(p)) = \n    println(s Published with ${p.publicationId} )\n}", 
            "title": "Acknowledge"
        }, 
        {
            "location": "/client/future/pubsub/#recover-exceptions_1", 
            "text": "You can either recover or  \"give up\"  when the (future of) publication fails. To recover from failures (such as  SessionException  when session turns out to be closed as you try to publish) you can compose  recoverWith   to attempt another session opening (maybe to a fallback realm and to a fallback topic):  val publication = session1.flatMap(_.publish( myapp.topic.ticking )\n  .recoverWith { \n    case ex: SessionException = \n      for {\n        session2  - client.openSession()\n        publication2  - session2.publish( myapp.topic.heartbeat )\n      }\n      yield publication2\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  publication.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover exceptions"
        }, 
        {
            "location": "/client/future/pubsub/#tickle", 
            "text": "You can easily publish a tick count to a topic with an initial delay and frequency.  import scala.concurrent.duration._\n\nval tickling: Future[Cancelable] = session.flatMap(\n  _.tickle(\n    topic =  myapp.topic.ticks , \n    delay = Duration.Zero, \n    interval = 1 second)\n  ))", 
            "title": "Tickle"
        }, 
        {
            "location": "/client/future/rpc/", 
            "text": "Remote Procedure Calls\n\n\nimport akka.wamp.client._\nimport akka.wamp.serialization._\n\nobject MyClientApp extends App {\n  val client = Client()  \n  implicit val ec = client.executionContext\n\n  val data = \n    for {\n      session \n- client\n        .openSession(\n          url = \nws://localhost:8080/ws\n,\n          realm = \nmyapp.realm\n)\n      registration \n- session\n        .register(\n          procedure = \nmyapp.procedure.sum\n,\n          handler = (a: Int, b: Int) =\n a + b)\n      result \n- session\n        .call(\n          procedure = \nmyapp.procedure.multiply\n,\n          args = List(23.5, 12.89))\n      data \n- result.data\n    } \n    yield data\n\n  data.map(println)\n}\n\n\n\n\nThe WAMP protocol defines a routed Remote Procedure Call (RPC) mechanism which relies on the same sort of decoupling that is used by the \nPublish Subscribe\n communication pattern. \n\n\nA client, the callee, announces to the dealer router that it provides a certain procedure, identified by a procedure name.  Other clients, callers, can then call the procedure, with the dealer router invoking the procedure on the callee, receiving the procedure's result, and then forwarding this result back to the callers. Routed RPC differ from traditional client-server RPC in that the dealer router serves as an intermediary between the callers and the callee.\n\n\n   ,------.          ,------.               ,------.\n   |Caller|          |Dealer|               |Callee|\n   `--+---'          `--+---'               `--+---'   \n      |                 |             REGISTER |\n      |                 \n---------------------|\n      |                 |                      |\n      |                 | REGISTERED           |\n      |                 |---------------------\n\n      |                 |                      |\n      | CALL            |                      |\n      |----------------\n                      |\n      |                 |                      |\n      |                 | INVOCATION           | \n      |                 |---------------------\n\n      |                 |                      |\n      |                 |                YIELD |\n      |                 \n---------------------|\n      |                 |                      |\n      |          RESULT |                      |\n      \n----------------|                      |\n   ,--+---.          ,--+---.               ,--+---.\n   |Caller|          |Dealer|               |Callee|\n   `------'          `------'               `------'\n\n\n\n\nAkka Wamp provides you with an \nFuture\n based API to easily write both kind of clients: callee (those registering procedures) and callers (those calling them).\n\n\nRegister procedures\n\n\nOnce you got a session, you can register procedures:\n\n\n// val session = ... \n\nfor {\n  ssn \n- session\n  registration1 \n- ssn.register(\n    procedure = \nmyapp.procedure.sum\n,\n    handler = (a: Int, b: Int) =\n a + b)\n  registration2 \n- ssn.register(\n    procedure = \nmyapp.procedure.echo\n,\n    handler = { i: Invocation =\n i.args.map(Payload(_)) })\n} \nyield ()\n\n\n\n\nA (future of) session can be mapped to a (future of) registration by invoking one of the provided \nregister()\n methods. \n\n\n// passing any of the scala.Function as handler\ndef register[F](procedure: Uri, handler: F)\n\n// passing an AkkaWamp invocation handler\ndef register(procedure: Uri, handler: InvocationHandler)\n\n\n\n\nThey accept \n\n\n\n\nprocedure\n URI as documented for the \nRegister\n message\n\n\nand they accept either      \n\n\nany of the \nscala.Function\n types\n\n\nor an \nakka.wamp.InvocationHandler\n\n\n\n\n\n\n\n\nHandle with \nscala.Function\n\n\nAs you probably know, following are some alternative ways to define functions and partially applied functions in Scala. \n\n\n// equivalent functions\ndef sum (a: Int, b: Int): Int = a + b\nval total = (a: Int, b: Int): Int =\n a + b\nval add: Function2[Int, Int, Int] = a + b\nval plus: (Int, Int) =\n Int = a + b\n\n// partially applied functions\nval a = add(8, _)\nval p = plus(_, 12)\nval s = sum _\n\n\n\n\nYou can register a procedure URI with either an anonymous function or a named partially applied function as handler.\n\n\nval registration1: Future[Registration] = session.flatMap(\n  _.register(\n    procedure = \nmyapp.procedure.sum1\n,\n    handler = (Int, Int) =\n Int = a + b ))\n\nval registration2: Future[Registration] = session.flatMap(\n  _.register(\n    procedure = \nmyapp.procedure.sum2\n,\n    handler = sum _ ))\n\n\n\n\nAkka Wamp will dinamically invoke the function you provide as handler (e.g. \nsum _\n) upon receiving invocations addressed to the registered procedure URI (e.g. \n\"myapp.procedure.sum\"\n). It will lazily deserialize the \nargs\n list from incoming payloads by using its default type bindings as documented in the \nPayload Handling\n section. \n\n\n\n\nNotice\n\nLazy deserialization from incoming \nkwargs\n and dynamic invocation passing input values to named arguments is not yet supported (see \nissue/41\n)\n\n\n\n\nHandle with \nInvocationHandler\n\n\nAn invocation handler is a function that transforms an \nInvocation\n message to a (future of) \nPayload\n to be replied back to the caller in a \nResult\n message.\n\n\ntype InvocationHandler = (Invocation) =\n Future[Payload]\n\n\n\n\nYou can register a procedure URI and provide your custom invocation handler. Doing that you'll be put in charge of deserializing either the \nargs\n list or the \nkwargs\n dictionary from the incoming payload \n\n\n// handler for \nmyapp.procedure.sum\n\nval handler: InvocationHandler = { invocation =\n\n  invocation.kwargs.map { kwargs =\n\n    val a = kwargs(\na\n).asInstanceOf[Int]\n    val b = kwargs(\nb\n).asInstanceOf[Int]\n    Payload(List(a + b))\n  }}\n\n\n\n\nThough more complicated than handling with \nscala.Function\n, this technique gives you much more flexibility because you can \n\n\n\n\ndeserialize by applying custom type bindings (e.g. deserialize your custom application types rather than primitive ones) or \n\n\neven deserialize formats different than JSON/MsgPack (e.g. you can deserialize Apache Avro or Google Protocol Buffer if you wish!) \n\n\n\n\nPlease read the \nPayload Handling\n section for further details.\n\n\nRecover exceptions\n\n\nYou can either recover or \n\"give up\"\n when the (future of) registration fails. To recover from failures (such as \nSessionException\n thrown when the procedure has been already registered by some other callee or when the session turns out to be closed) you can compose \nrecoverWith\n to attempt registering the procedure with a different name or to attempt another session (maybe to a fallback realm):\n\n\nval registration = session.flatMap(\n  _.register(\nmyapp.procedure.sum\n)(handler)\n  .recoverWith { \n    case ex: SessionException =\n session.flatMap(\n      _.register(\nmyapp.procedure.sum.renamed\n)(handler)\n  }\n\n\n\n\nAs last resort, instead of recovering, you could decide to \n\"give up\"\n a callback function \nonFailure\n that just prints a log message:\n\n\nsession.onFailure {\n  case ex: Throwable =\n \n    log.error(ex.getMessage, ex)\n}\n\n\n\n\nUnregister procedures\n\n\nimport akka.wamp.messages._\n\nval registration: Future[Registration] = ...\n\nval unregistered: Future[Unregistered] = registration.flatMap(\n  _.unregister()\n)\n\n\n\n\nJust call the \nunregister()\n method on the registration you want to terminate.\n\n\nRecover exceptions\n\n\nTBD\n\n\nCall procedures\n\n\nOnce you got a session, as documented in the \nSession Handling\n section, you can call a procedure:\n\n\n// val session = ... \n\nval result: Future[Result] = session.flatMap(\n  _.call(\n    procedure = \nmyapp.procedure.sum\n,\n    args = List(2, 4, 8, 12))\n)\n\nval data: Future[List[Any]] = result.flatMap(\n  _.data\n)\n\n\n\n\nArguments can be received from the resulting payload as documented in the \nPayload Handling\n section.\n\n\nRecover exceptions\n\n\nTBD", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/client/future/rpc/#remote-procedure-calls", 
            "text": "import akka.wamp.client._\nimport akka.wamp.serialization._\n\nobject MyClientApp extends App {\n  val client = Client()  \n  implicit val ec = client.executionContext\n\n  val data = \n    for {\n      session  - client\n        .openSession(\n          url =  ws://localhost:8080/ws ,\n          realm =  myapp.realm )\n      registration  - session\n        .register(\n          procedure =  myapp.procedure.sum ,\n          handler = (a: Int, b: Int) =  a + b)\n      result  - session\n        .call(\n          procedure =  myapp.procedure.multiply ,\n          args = List(23.5, 12.89))\n      data  - result.data\n    } \n    yield data\n\n  data.map(println)\n}  The WAMP protocol defines a routed Remote Procedure Call (RPC) mechanism which relies on the same sort of decoupling that is used by the  Publish Subscribe  communication pattern.   A client, the callee, announces to the dealer router that it provides a certain procedure, identified by a procedure name.  Other clients, callers, can then call the procedure, with the dealer router invoking the procedure on the callee, receiving the procedure's result, and then forwarding this result back to the callers. Routed RPC differ from traditional client-server RPC in that the dealer router serves as an intermediary between the callers and the callee.     ,------.          ,------.               ,------.\n   |Caller|          |Dealer|               |Callee|\n   `--+---'          `--+---'               `--+---'   \n      |                 |             REGISTER |\n      |                  ---------------------|\n      |                 |                      |\n      |                 | REGISTERED           |\n      |                 |--------------------- \n      |                 |                      |\n      | CALL            |                      |\n      |----------------                       |\n      |                 |                      |\n      |                 | INVOCATION           | \n      |                 |--------------------- \n      |                 |                      |\n      |                 |                YIELD |\n      |                  ---------------------|\n      |                 |                      |\n      |          RESULT |                      |\n       ----------------|                      |\n   ,--+---.          ,--+---.               ,--+---.\n   |Caller|          |Dealer|               |Callee|\n   `------'          `------'               `------'  Akka Wamp provides you with an  Future  based API to easily write both kind of clients: callee (those registering procedures) and callers (those calling them).", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/client/future/rpc/#register-procedures", 
            "text": "Once you got a session, you can register procedures:  // val session = ... \n\nfor {\n  ssn  - session\n  registration1  - ssn.register(\n    procedure =  myapp.procedure.sum ,\n    handler = (a: Int, b: Int) =  a + b)\n  registration2  - ssn.register(\n    procedure =  myapp.procedure.echo ,\n    handler = { i: Invocation =  i.args.map(Payload(_)) })\n} \nyield ()  A (future of) session can be mapped to a (future of) registration by invoking one of the provided  register()  methods.   // passing any of the scala.Function as handler\ndef register[F](procedure: Uri, handler: F)\n\n// passing an AkkaWamp invocation handler\ndef register(procedure: Uri, handler: InvocationHandler)  They accept    procedure  URI as documented for the  Register  message  and they accept either        any of the  scala.Function  types  or an  akka.wamp.InvocationHandler", 
            "title": "Register procedures"
        }, 
        {
            "location": "/client/future/rpc/#handle-with-scalafunction", 
            "text": "As you probably know, following are some alternative ways to define functions and partially applied functions in Scala.   // equivalent functions\ndef sum (a: Int, b: Int): Int = a + b\nval total = (a: Int, b: Int): Int =  a + b\nval add: Function2[Int, Int, Int] = a + b\nval plus: (Int, Int) =  Int = a + b\n\n// partially applied functions\nval a = add(8, _)\nval p = plus(_, 12)\nval s = sum _  You can register a procedure URI with either an anonymous function or a named partially applied function as handler.  val registration1: Future[Registration] = session.flatMap(\n  _.register(\n    procedure =  myapp.procedure.sum1 ,\n    handler = (Int, Int) =  Int = a + b ))\n\nval registration2: Future[Registration] = session.flatMap(\n  _.register(\n    procedure =  myapp.procedure.sum2 ,\n    handler = sum _ ))  Akka Wamp will dinamically invoke the function you provide as handler (e.g.  sum _ ) upon receiving invocations addressed to the registered procedure URI (e.g.  \"myapp.procedure.sum\" ). It will lazily deserialize the  args  list from incoming payloads by using its default type bindings as documented in the  Payload Handling  section.    Notice \nLazy deserialization from incoming  kwargs  and dynamic invocation passing input values to named arguments is not yet supported (see  issue/41 )", 
            "title": "Handle with scala.Function"
        }, 
        {
            "location": "/client/future/rpc/#handle-with-invocationhandler", 
            "text": "An invocation handler is a function that transforms an  Invocation  message to a (future of)  Payload  to be replied back to the caller in a  Result  message.  type InvocationHandler = (Invocation) =  Future[Payload]  You can register a procedure URI and provide your custom invocation handler. Doing that you'll be put in charge of deserializing either the  args  list or the  kwargs  dictionary from the incoming payload   // handler for  myapp.procedure.sum \nval handler: InvocationHandler = { invocation = \n  invocation.kwargs.map { kwargs = \n    val a = kwargs( a ).asInstanceOf[Int]\n    val b = kwargs( b ).asInstanceOf[Int]\n    Payload(List(a + b))\n  }}  Though more complicated than handling with  scala.Function , this technique gives you much more flexibility because you can    deserialize by applying custom type bindings (e.g. deserialize your custom application types rather than primitive ones) or   even deserialize formats different than JSON/MsgPack (e.g. you can deserialize Apache Avro or Google Protocol Buffer if you wish!)    Please read the  Payload Handling  section for further details.", 
            "title": "Handle with InvocationHandler"
        }, 
        {
            "location": "/client/future/rpc/#recover-exceptions", 
            "text": "You can either recover or  \"give up\"  when the (future of) registration fails. To recover from failures (such as  SessionException  thrown when the procedure has been already registered by some other callee or when the session turns out to be closed) you can compose  recoverWith  to attempt registering the procedure with a different name or to attempt another session (maybe to a fallback realm):  val registration = session.flatMap(\n  _.register( myapp.procedure.sum )(handler)\n  .recoverWith { \n    case ex: SessionException =  session.flatMap(\n      _.register( myapp.procedure.sum.renamed )(handler)\n  }  As last resort, instead of recovering, you could decide to  \"give up\"  a callback function  onFailure  that just prints a log message:  session.onFailure {\n  case ex: Throwable =  \n    log.error(ex.getMessage, ex)\n}", 
            "title": "Recover exceptions"
        }, 
        {
            "location": "/client/future/rpc/#unregister-procedures", 
            "text": "import akka.wamp.messages._\n\nval registration: Future[Registration] = ...\n\nval unregistered: Future[Unregistered] = registration.flatMap(\n  _.unregister()\n)  Just call the  unregister()  method on the registration you want to terminate.", 
            "title": "Unregister procedures"
        }, 
        {
            "location": "/client/future/rpc/#recover-exceptions_1", 
            "text": "TBD", 
            "title": "Recover exceptions"
        }, 
        {
            "location": "/client/future/rpc/#call-procedures", 
            "text": "Once you got a session, as documented in the  Session Handling  section, you can call a procedure:  // val session = ... \n\nval result: Future[Result] = session.flatMap(\n  _.call(\n    procedure =  myapp.procedure.sum ,\n    args = List(2, 4, 8, 12))\n)\n\nval data: Future[List[Any]] = result.flatMap(\n  _.data\n)  Arguments can be received from the resulting payload as documented in the  Payload Handling  section.", 
            "title": "Call procedures"
        }, 
        {
            "location": "/client/future/rpc/#recover-exceptions_2", 
            "text": "TBD", 
            "title": "Recover exceptions"
        }, 
        {
            "location": "/client/future/payload/", 
            "text": "Payload Handling\n\n\nWAMP messages, formatted as textual JSON or binary MsgPack, are transmitted by an underlying transport like WebSocket or RawTCP. Messages are all made of few headers and an optional payload. \n\n\nframe2                  frame1                             \n.-------------.        .-------------,---------.    \n| payload ... |  --\n   | ... payload | headers |  --\n  \n'-------------'        '-------------`---------'     \n\n\n\n\nThe payload contains application data either as a list or as a dictionary of arguments. The payload is always at the end of the message and for some applications (such a BigData or Multimedia Streaming applications), it could be of such a big size that some transports have to split messages in frames.\n\n\nReceive payloads\n\n\nAkka Wamp provides efficient deserializers, implemented using streaming technologies, which do not eagerly parse the contents of incoming payloads but rather return lazy structures to defer parsing to the very last moment.  That lazy structures in question are implemented internally as \nLazyTextPayload\n and \nLazyBinaryPayload\n types.\n\n\n,-------------.  holds     ,-----------.\n|PayloadHolder|----------\n|  Payload  |\n`-------------'            `-----+-----'\n                                 ^\n                                 | inherits\n                   .-------------+-------------. \n                   |                           |\n           ,-------+-------.          ,--------+--------.\n           |LazyTextPayload|          |LazyBinaryPayload|\n           `---------------'          `-----------------'\n\n\n\n\nIncoming messages that can hold a lazy payload are summarized by the following table alongside the client role that receives them: \n\n\n\n\n\n\n\n\nMessage\n\n\nReceiver\n\n\nHandler\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nSubscriber\n\n\nEventHandler\n\n\n\n\n\n\nInvocation\n\n\nCallee\n\n\nInvocationHandler\n\n\n\n\n\n\nResult\n\n\nCaller\n\n\n\n\n\n\n\n\n\n\nAccess parsed data/arguments\n\n\nYou can let Akka Wamp lazily parse the content of incoming payloads on behalf of your client. Your subscriber, callee or caller can access data/arguments parsed by Akka Wamp as (future of) Scala collections of arbitrary types but deserialized with default data type bindings. \n\n\nFor example, a subscriber client can access parsed event data as follows:\n\n\nval handler: EventHandler = { event =\n\n  val data: Future[List[Any] = event.data\n  val kwdata: Future[Map[String, Any]] = event.kwdata\n\n  // ...\n}\n\n\n\n\nSimilarly, a callee client can access parsed invocation arguments as follows:\n\n\nval handler: InvocationHandler = { invocation =\n\n  val args: Future[List[Any] = invocation.args\n  val kwargs: Future[Map[String, Any]] = invocation.kwargs\n\n  // ...\n}\n\n\n\n\n\n\nDefault type bindings\n\n\nBy default, Akka Wamp makes use of either the embedded \nJackson JSON Parser\n (for textual data) or the embedded \nMsgPack Parser\n (for binary data) and deserializes incoming data/arguments to Scala collection whose values match the following data type bindings:\n\n\n\n\n\n\n\n\nJSON\n\n\nMsgPack\n\n\nScala\n\n\n\n\n\n\n\n\n\n\nstring\n\n\n\n\njava.lang.\nString\n\n\n\n\n\n\nnumber\n\n\n\n\njava.lang.\nInteger\n, java.lang.\nLong\n, java.lang.\nDouble\n\n\n\n\n\n\nobject\n\n\n\n\nscala.collection.immutable.\nMap[String, _]\n\n\n\n\n\n\narray\n\n\n\n\nscala.collection.immutable.\nList[_]\n\n\n\n\n\n\ntrue\n\n\n\n\njava.lang.\nBoolean\n\n\n\n\n\n\nfalse\n\n\n\n\njava.lang.\nBoolean\n\n\n\n\n\n\nnull\n\n\n\n\nscala.\nNone\n\n\n\n\n\n\n\n\nCustom data type bindings\n\n\nTBD\n\n\nAccess unparsed content\n\n\n\n\nWARNING\n\nThis is an experimental feature that has not been released yet!\n\n\n\n\nYour clients (either of role subscriber, callee or caller) can access incoming unparsed payload content by consuming an Akka Stream source. It comes in handy for those applications exchanging huge amount of data. But bear in mind that you will be put in charge of parsing payload content appropriately:\n\n\nimport akka.stream.scaladsl._\nimport akka.wamp.serialization._\n\nval handler: EventHandler = { event =\n\n  event.payload match {\n    case payload: BinaryPayload =\n\n      log.warn(\nUnexpected binaray payload\n)\n\n    case payload: TextPayload =\n\n      val source: Source[String] = payload.source\n      // ... consume/parse the Akka Stream source ...\n      ()\n  }\n  // ...\n}\n\n\n\n\nYou can match the payload against \nTextPayload\n or \nBinaryPayload\n, get its Akka Stream source, then create whatever Akka Stream graph you need (composing flows and sink) and finally run the stream to parse the payload contents at your best convenience.\n\n\nExamples\n\n\nTBD\n\n\nJSON\n\n\nTBD\n\n\nYAML\n\n\nTBD\n\n\nMsgPack\n\n\nTBD\n\n\nApache Avro\n\n\nTBD\n\n\nSend payloads\n\n\nTBD", 
            "title": "Payload Handling"
        }, 
        {
            "location": "/client/future/payload/#payload-handling", 
            "text": "WAMP messages, formatted as textual JSON or binary MsgPack, are transmitted by an underlying transport like WebSocket or RawTCP. Messages are all made of few headers and an optional payload.   frame2                  frame1                             \n.-------------.        .-------------,---------.    \n| payload ... |  --    | ... payload | headers |  --   \n'-------------'        '-------------`---------'       The payload contains application data either as a list or as a dictionary of arguments. The payload is always at the end of the message and for some applications (such a BigData or Multimedia Streaming applications), it could be of such a big size that some transports have to split messages in frames.", 
            "title": "Payload Handling"
        }, 
        {
            "location": "/client/future/payload/#receive-payloads", 
            "text": "Akka Wamp provides efficient deserializers, implemented using streaming technologies, which do not eagerly parse the contents of incoming payloads but rather return lazy structures to defer parsing to the very last moment.  That lazy structures in question are implemented internally as  LazyTextPayload  and  LazyBinaryPayload  types.  ,-------------.  holds     ,-----------.\n|PayloadHolder|---------- |  Payload  |\n`-------------'            `-----+-----'\n                                 ^\n                                 | inherits\n                   .-------------+-------------. \n                   |                           |\n           ,-------+-------.          ,--------+--------.\n           |LazyTextPayload|          |LazyBinaryPayload|\n           `---------------'          `-----------------'  Incoming messages that can hold a lazy payload are summarized by the following table alongside the client role that receives them:      Message  Receiver  Handler      Event  Subscriber  EventHandler    Invocation  Callee  InvocationHandler    Result  Caller", 
            "title": "Receive payloads"
        }, 
        {
            "location": "/client/future/payload/#access-parsed-dataarguments", 
            "text": "You can let Akka Wamp lazily parse the content of incoming payloads on behalf of your client. Your subscriber, callee or caller can access data/arguments parsed by Akka Wamp as (future of) Scala collections of arbitrary types but deserialized with default data type bindings.   For example, a subscriber client can access parsed event data as follows:  val handler: EventHandler = { event = \n  val data: Future[List[Any] = event.data\n  val kwdata: Future[Map[String, Any]] = event.kwdata\n\n  // ...\n}  Similarly, a callee client can access parsed invocation arguments as follows:  val handler: InvocationHandler = { invocation = \n  val args: Future[List[Any] = invocation.args\n  val kwargs: Future[Map[String, Any]] = invocation.kwargs\n\n  // ...\n}", 
            "title": "Access parsed data/arguments"
        }, 
        {
            "location": "/client/future/payload/#default-type-bindings", 
            "text": "By default, Akka Wamp makes use of either the embedded  Jackson JSON Parser  (for textual data) or the embedded  MsgPack Parser  (for binary data) and deserializes incoming data/arguments to Scala collection whose values match the following data type bindings:     JSON  MsgPack  Scala      string   java.lang. String    number   java.lang. Integer , java.lang. Long , java.lang. Double    object   scala.collection.immutable. Map[String, _]    array   scala.collection.immutable. List[_]    true   java.lang. Boolean    false   java.lang. Boolean    null   scala. None", 
            "title": "Default type bindings"
        }, 
        {
            "location": "/client/future/payload/#custom-data-type-bindings", 
            "text": "TBD", 
            "title": "Custom data type bindings"
        }, 
        {
            "location": "/client/future/payload/#access-unparsed-content", 
            "text": "WARNING \nThis is an experimental feature that has not been released yet!   Your clients (either of role subscriber, callee or caller) can access incoming unparsed payload content by consuming an Akka Stream source. It comes in handy for those applications exchanging huge amount of data. But bear in mind that you will be put in charge of parsing payload content appropriately:  import akka.stream.scaladsl._\nimport akka.wamp.serialization._\n\nval handler: EventHandler = { event = \n  event.payload match {\n    case payload: BinaryPayload = \n      log.warn( Unexpected binaray payload )\n\n    case payload: TextPayload = \n      val source: Source[String] = payload.source\n      // ... consume/parse the Akka Stream source ...\n      ()\n  }\n  // ...\n}  You can match the payload against  TextPayload  or  BinaryPayload , get its Akka Stream source, then create whatever Akka Stream graph you need (composing flows and sink) and finally run the stream to parse the payload contents at your best convenience.", 
            "title": "Access unparsed content"
        }, 
        {
            "location": "/client/future/payload/#examples", 
            "text": "TBD", 
            "title": "Examples"
        }, 
        {
            "location": "/client/future/payload/#json", 
            "text": "TBD", 
            "title": "JSON"
        }, 
        {
            "location": "/client/future/payload/#yaml", 
            "text": "TBD", 
            "title": "YAML"
        }, 
        {
            "location": "/client/future/payload/#msgpack", 
            "text": "TBD", 
            "title": "MsgPack"
        }, 
        {
            "location": "/client/future/payload/#apache-avro", 
            "text": "TBD", 
            "title": "Apache Avro"
        }, 
        {
            "location": "/client/future/payload/#send-payloads", 
            "text": "TBD", 
            "title": "Send payloads"
        }, 
        {
            "location": "/client/stream/", 
            "text": "Stream based API overview\n\n\nWorking in progress.", 
            "title": "Stream based API"
        }, 
        {
            "location": "/client/stream/#stream-based-api-overview", 
            "text": "Working in progress.", 
            "title": "Stream based API overview"
        }, 
        {
            "location": "/client/config/", 
            "text": "Configuration\n\n\nakka {\n  wamp {\n    client {\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # NOTE\n      # Clients will always disconnect on offending messages\n      # No configuration settings is provided to change this behaviour.\n      #\n    }\n  }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/client/config/#configuration", 
            "text": "akka {\n  wamp {\n    client {\n      # The boolean switch to validate against strict URIs \n      # rather than loose URIs\n      #\n      validate-strict-uris = false\n\n      # NOTE\n      # Clients will always disconnect on offending messages\n      # No configuration settings is provided to change this behaviour.\n      #\n    }\n  }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/messages/", 
            "text": "Messages\n\n\nTBD \n\n\nSession Handling\n\n\n   ,------.                                    ,------.\n   | Peer |                                    | Peer |\n   `--+---'                                    `--+---'\n      |               TCP established             |\n      |\n-----------------------------------------\n|\n      |                                           |\n      |               TLS established             |\n      |+\n---------------------------------------\n+|\n      |+                                         +|\n      |+           WebSocket established         +|\n      |+|\n-------------------------------------\n|+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|                                       |+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+\n-----------------------------------\n+|+|\n      |+|                                       |+|\n      |+|           WebSocket closed            |+|\n      |+|\n-------------------------------------\n|+|\n      |+                                         +|\n      |+              TLS closed                 +|\n      |+\n---------------------------------------\n+|\n      |                                           |\n      |               TCP closed                  |\n      |\n-----------------------------------------\n|\n      |                                           |\n   ,--+---.                                    ,--+---.\n   | Peer |                                    | Peer |\n   `------'                                    `------'\n\n\n\n\n\n\nConnect\n\n\nIt is the message your client application sends to the \nAkka I/O extension manager\n to connect a transport to a remote router. It can be constructed passing the following parameters:\n\n\n\n\n\n\nclient\n\n  It is your client actor reference to which messages from the router are delivered back.\n\n\n\n\n\n\nurl\n\n  It is the \nURL\n of the router listener. By default Akka Wamp makes use of \nws://127.0.0.1:8080/ws\n and it currently supports the following protocols:\n\n\n\n\ntcp\n\n    Raw TCP\n\n\ntsl\n\n    Transport Secure Layer\n\n\nws\n\n    WebSocket \n\n\nwss\n\n    WebSocket over TLS\n\n\n\n\n\n\n\n\nsubprotocol\n\n  It is the \nsubprotocol\n you wish to negotiate with the router. By default Akka Wamp makes use of \nwamp.2.json\n and it currently supports the following subprotocols:\n\n\n\n\nwamp.2.json\n\n\nwamp.2.msgpack\n\n\n\n\n\n\n\n\nExamples:\n\n\nIO(Wamp) ! Connect(client)\nIO(Wamp) ! Connect(client, url = \nwss://secured.host.net:8433/path/to/router\n)\nIO(Wamp) ! Connect(client, subprotocol = \nwamp.2.mgspack\n)\n\n\n\n\n\n\nHello\n\n\nIt is the message your client application sends to the router to request a new session being opened with the given realm attached plus additional details. It can be constructed passing the following parameters:\n\n\n\n\n\n\nrealm\n\n  It is the realm identifier given as \nURI\n. By default, Akka Wamp sends \ndefault.realm\n\n\n\n\n\n\ndetails\n\n   It is a dictionary of additional details. By default, Akka Wamp makes a dictionary with all possible client roles its supports:\n\n\n\n\nsubscriber\n\n\npublisher\n\n\n\n\n\n\n\n\nExamples:\n\n\nconnection ! Hello()\nconnection ! Hello(\nmyapp.realm\n)\nconnection ! Hello(details = Dict().withRoles(\nsubscriber\n))\nconnection ! Hello(\nmyapp.realm\n, Dict().withRoles(\npublisher\n))\n\n\n\n\n\n\nAbort\n\n\nTBD\n\n\n\n\nWelcome\n\n\nIt is the message you receive from the router upon session opening. It can be deconstructed (via Scala pattern matching) to the following parameters:\n\n\n\n\n\n\nsessionId\n\n  It is the session identifier as generated by the router.\n\n\n\n\n\n\ndetails\n\n  It is a dictionary with additional details (for example the router agent identifier)\n\n\n\n\n\n\nExamples:\n\n\nval sessionId: Long = _\n\ndef receive: Receive = {\n  case Welcome(sessionId, details) =\n\n    log info s\nSession $sessionId opened with $details\n\n    this.sessionId = sessionId\n    context become opened\n}\n\ndef opened: Receive = {\n  case Goodbye =\n\n    this.sessionId = 0\n\n  // case ...  \n}\n\n\n\n\n\n\nGoodbye\n\n\nIt is the message either your client application sends to the router or receive from the router to request session closing. It can be constructed (deconstructed) with (to) the following parameters:\n\n\n\n\n\n\nreason\n\n  It is the reason identifier given as \nsession close URI\n. By default, Akka Wamp sends \nwamp.error.close_realm\n\n\n\n\n\n\ndetails\n\n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.\n\n\n\n\n\n\nSome sending snippets are:\n\n\nconnection ! Goodbye()\nconnection ! Goodbye(\nwamp.error.system_shutdown\n)\nconnection ! Goodbye(details = Dict().withEntry(reason -\n \nSerious error occured!\n))\n\n\n\n\nA receiving snippet is:\n\n\ndef opened: Receive = {\n  case Goodbye(reason, details) =\n\n    log warn s\nRouter closed session because of $details\n\n    connection ! Goodbye(\nwamp.error.goodbye_and_out\n)\n    if (reason != \nwamp.error.system_shutdown\n)\n      // why not requesting a new session \n      connection ! Hello\n    else\n      IO(Wamp) ! Connect(self)\n}\n\n\n\n\n\n\nNOTE: there's an open [issue#242]((https://github.com/wamp-proto/wamp-proto/issues/242) on GitHub about the \nGoodbye\n message to warn you that some remote routers could decide to disconnect the transport in addition to close the session. If that happens the you'll be forced to reconnect.\n\n\n\n\n\n\nError\n\n\nTBD\n\n\nPublish Subscribe\n\n\n\n\nSubscribe\n\n\nIt is the message your client application sends to the router to subscribe to a topic. It can be constructed passing the following parameters:\n\n\n\n\n\n\nrequestId\n\n  It is the request identifier you have to generate in \n\"session scope\"\n. AkkaWamp provides you with a \nScope.Session\n trait you can mixin to invoke \nnextId()\n\n\n\n\n\n\ntopic\n\n  It is the topic URI you want to subscribe to.\n\n\n\n\n\n\noptions\n\n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.\n\n\n\n\n\n\nExamples:\n\n\nconnection ! Subscribe(requestId = 34, \nmyapp.tick.topic\n)\n\n\n\n\n\n\nSubscribed\n\n\nTBD\n\n\n\n\nPublish\n\n\nIt is the message your client application sends to the router to publish an event. It can be constructed passing the following parameters:\n\n\n\n\n\n\nrequestId\n\n  It is the request identifier you have to generate in \n\"session scope\"\n. AkkaWamp provides you with a \nScope.Session\n trait you can mixin to invoke \nnextId()\n\n\n\n\n\n\ntopic\n\n  It is the topic URI to which you wish to publish to\n\n\n\n\n\n\npayload\n\n  It is the (option of) payload you could provide to send data arguments. By default, Akka Wamp sends none but you could create some as documented in the \nPayload\n section below.\n\n\n\n\n\n\noptions\n\n  It is a dictionary of additional details (for example with the \n\"acknowledge\" -\n true\n entry if you wish to receive the \nPublished\n message from the router). By default, Akka Wamp sends an empty dictionary.\n\n\n\n\n\n\nExamples:\n\n\nconnection ! Publish(requestId = 34, \nmyapp.tick.topic\n)\n\nval list = Payload(\npaolo\n, 40, true)\nconnection ! Publish(nextId(), \nmyapp.topic1\n, Some(list))\n\nval mixed = Payload(\npaolo\n, \nage\n-\n40, true)\nconnection ! Publish(nextId(), \nmyapp.topic1\n, Some(mixed))\n\nconnection ! Publish(89, \nmyapp.topic3\n, options = Dict().withAcknowledge(true))\n\n\n\n\n\n\nEvent\n\n\nIt is the message you receive from the router each time other clients have published to the same topics you subscribed to. It can be deconstructed (via Scala pattern matching) to the following parameters:\n\n\n\n\n\n\nsubscriptionId\n  \n\n  It is the subscription identifier you could use to figure out which topic the event has been fired for.\n\n\n\n\n\n\npublicationId\n  \n\n   It is the publication identifier generated by the router in global scope.\n\n\n\n\n\n\npayload\n  \n\n  It is the (option of) payload with data arguments you could read as documented in the \nPayload\n section below.\n\n\n\n\n\n\ndetails\n\n  It is a dictionary with additional details.\n\n\n\n\n\n\nExamples:\n\n\nval subscriptionId: Long = _\n\ndef opened: Receive = {\n  case Event(subscriptionId, publicationId, None, details) =\n\n    log debug s\nEvent received for subscription $subscriptionId\n\n\n  case Event(_, _, Some(payload), _) =\n\n    log debug s\nEvent receive with payload $payload\n\n}\n\n\n\n\nRemote Procedure Calls\n\n\n\n\nRegister\n\n\nTBD\n\n\n\n\nCall\n\n\nTBD\n\n\n\n\nInvocation\n\n\nTBD\n\n\n\n\nYield\n\n\nTBD\n\n\n\n\nResult\n\n\nTBD", 
            "title": "Messages"
        }, 
        {
            "location": "/messages/#messages", 
            "text": "TBD", 
            "title": "Messages"
        }, 
        {
            "location": "/messages/#session-handling", 
            "text": ",------.                                    ,------.\n   | Peer |                                    | Peer |\n   `--+---'                                    `--+---'\n      |               TCP established             |\n      | ----------------------------------------- |\n      |                                           |\n      |               TLS established             |\n      |+ --------------------------------------- +|\n      |+                                         +|\n      |+           WebSocket established         +|\n      |+| ------------------------------------- |+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+ ----------------------------------- +|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+ ----------------------------------- +|+|\n      |+|                                       |+|\n      |+|                                       |+|\n      |+|            WAMP established           |+|\n      |+|+ ----------------------------------- +|+|\n      |+|+                                     +|+|\n      |+|+                                     +|+|\n      |+|+            WAMP closed              +|+|\n      |+|+ ----------------------------------- +|+|\n      |+|                                       |+|\n      |+|           WebSocket closed            |+|\n      |+| ------------------------------------- |+|\n      |+                                         +|\n      |+              TLS closed                 +|\n      |+ --------------------------------------- +|\n      |                                           |\n      |               TCP closed                  |\n      | ----------------------------------------- |\n      |                                           |\n   ,--+---.                                    ,--+---.\n   | Peer |                                    | Peer |\n   `------'                                    `------'", 
            "title": "Session Handling"
        }, 
        {
            "location": "/messages/#connect", 
            "text": "It is the message your client application sends to the  Akka I/O extension manager  to connect a transport to a remote router. It can be constructed passing the following parameters:    client \n  It is your client actor reference to which messages from the router are delivered back.    url \n  It is the  URL  of the router listener. By default Akka Wamp makes use of  ws://127.0.0.1:8080/ws  and it currently supports the following protocols:   tcp \n    Raw TCP  tsl \n    Transport Secure Layer  ws \n    WebSocket   wss \n    WebSocket over TLS     subprotocol \n  It is the  subprotocol  you wish to negotiate with the router. By default Akka Wamp makes use of  wamp.2.json  and it currently supports the following subprotocols:   wamp.2.json  wamp.2.msgpack     Examples:  IO(Wamp) ! Connect(client)\nIO(Wamp) ! Connect(client, url =  wss://secured.host.net:8433/path/to/router )\nIO(Wamp) ! Connect(client, subprotocol =  wamp.2.mgspack )", 
            "title": "Connect"
        }, 
        {
            "location": "/messages/#hello", 
            "text": "It is the message your client application sends to the router to request a new session being opened with the given realm attached plus additional details. It can be constructed passing the following parameters:    realm \n  It is the realm identifier given as  URI . By default, Akka Wamp sends  default.realm    details \n   It is a dictionary of additional details. By default, Akka Wamp makes a dictionary with all possible client roles its supports:   subscriber  publisher     Examples:  connection ! Hello()\nconnection ! Hello( myapp.realm )\nconnection ! Hello(details = Dict().withRoles( subscriber ))\nconnection ! Hello( myapp.realm , Dict().withRoles( publisher ))", 
            "title": "Hello"
        }, 
        {
            "location": "/messages/#abort", 
            "text": "TBD", 
            "title": "Abort"
        }, 
        {
            "location": "/messages/#welcome", 
            "text": "It is the message you receive from the router upon session opening. It can be deconstructed (via Scala pattern matching) to the following parameters:    sessionId \n  It is the session identifier as generated by the router.    details \n  It is a dictionary with additional details (for example the router agent identifier)    Examples:  val sessionId: Long = _\n\ndef receive: Receive = {\n  case Welcome(sessionId, details) = \n    log info s Session $sessionId opened with $details \n    this.sessionId = sessionId\n    context become opened\n}\n\ndef opened: Receive = {\n  case Goodbye = \n    this.sessionId = 0\n\n  // case ...  \n}", 
            "title": "Welcome"
        }, 
        {
            "location": "/messages/#goodbye", 
            "text": "It is the message either your client application sends to the router or receive from the router to request session closing. It can be constructed (deconstructed) with (to) the following parameters:    reason \n  It is the reason identifier given as  session close URI . By default, Akka Wamp sends  wamp.error.close_realm    details \n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.    Some sending snippets are:  connection ! Goodbye()\nconnection ! Goodbye( wamp.error.system_shutdown )\nconnection ! Goodbye(details = Dict().withEntry(reason -   Serious error occured! ))  A receiving snippet is:  def opened: Receive = {\n  case Goodbye(reason, details) = \n    log warn s Router closed session because of $details \n    connection ! Goodbye( wamp.error.goodbye_and_out )\n    if (reason !=  wamp.error.system_shutdown )\n      // why not requesting a new session \n      connection ! Hello\n    else\n      IO(Wamp) ! Connect(self)\n}   NOTE: there's an open [issue#242]((https://github.com/wamp-proto/wamp-proto/issues/242) on GitHub about the  Goodbye  message to warn you that some remote routers could decide to disconnect the transport in addition to close the session. If that happens the you'll be forced to reconnect.", 
            "title": "Goodbye"
        }, 
        {
            "location": "/messages/#error", 
            "text": "TBD", 
            "title": "Error"
        }, 
        {
            "location": "/messages/#publish-subscribe", 
            "text": "", 
            "title": "Publish Subscribe"
        }, 
        {
            "location": "/messages/#subscribe", 
            "text": "It is the message your client application sends to the router to subscribe to a topic. It can be constructed passing the following parameters:    requestId \n  It is the request identifier you have to generate in  \"session scope\" . AkkaWamp provides you with a  Scope.Session  trait you can mixin to invoke  nextId()    topic \n  It is the topic URI you want to subscribe to.    options \n  It is a dictionary of additional details. By default, Akka Wamp sends an empty dictionary.    Examples:  connection ! Subscribe(requestId = 34,  myapp.tick.topic )", 
            "title": "Subscribe"
        }, 
        {
            "location": "/messages/#subscribed", 
            "text": "TBD", 
            "title": "Subscribed"
        }, 
        {
            "location": "/messages/#publish", 
            "text": "It is the message your client application sends to the router to publish an event. It can be constructed passing the following parameters:    requestId \n  It is the request identifier you have to generate in  \"session scope\" . AkkaWamp provides you with a  Scope.Session  trait you can mixin to invoke  nextId()    topic \n  It is the topic URI to which you wish to publish to    payload \n  It is the (option of) payload you could provide to send data arguments. By default, Akka Wamp sends none but you could create some as documented in the  Payload  section below.    options \n  It is a dictionary of additional details (for example with the  \"acknowledge\" -  true  entry if you wish to receive the  Published  message from the router). By default, Akka Wamp sends an empty dictionary.    Examples:  connection ! Publish(requestId = 34,  myapp.tick.topic )\n\nval list = Payload( paolo , 40, true)\nconnection ! Publish(nextId(),  myapp.topic1 , Some(list))\n\nval mixed = Payload( paolo ,  age - 40, true)\nconnection ! Publish(nextId(),  myapp.topic1 , Some(mixed))\n\nconnection ! Publish(89,  myapp.topic3 , options = Dict().withAcknowledge(true))", 
            "title": "Publish"
        }, 
        {
            "location": "/messages/#event", 
            "text": "It is the message you receive from the router each time other clients have published to the same topics you subscribed to. It can be deconstructed (via Scala pattern matching) to the following parameters:    subscriptionId    \n  It is the subscription identifier you could use to figure out which topic the event has been fired for.    publicationId    \n   It is the publication identifier generated by the router in global scope.    payload    \n  It is the (option of) payload with data arguments you could read as documented in the  Payload  section below.    details \n  It is a dictionary with additional details.    Examples:  val subscriptionId: Long = _\n\ndef opened: Receive = {\n  case Event(subscriptionId, publicationId, None, details) = \n    log debug s Event received for subscription $subscriptionId \n\n  case Event(_, _, Some(payload), _) = \n    log debug s Event receive with payload $payload \n}", 
            "title": "Event"
        }, 
        {
            "location": "/messages/#remote-procedure-calls", 
            "text": "", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/messages/#register", 
            "text": "TBD", 
            "title": "Register"
        }, 
        {
            "location": "/messages/#call", 
            "text": "TBD", 
            "title": "Call"
        }, 
        {
            "location": "/messages/#invocation", 
            "text": "TBD", 
            "title": "Invocation"
        }, 
        {
            "location": "/messages/#yield", 
            "text": "TBD", 
            "title": "Yield"
        }, 
        {
            "location": "/messages/#result", 
            "text": "TBD", 
            "title": "Result"
        }
    ]
}